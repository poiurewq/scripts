#!/usr/bin/env bash
# clock v2
#   single unified csv for easier analysis & porting to other apps
#   minimal POSIX-set sh-compliant instead of zsh so as to enable mobile recording on iSH with ash on iPhone (when porting to iSH, change the shebang to ash.)
#     does not use shebang since it should work on both zsh (Mac) and ash (iSH)
#   no fancy stuff not found in busybox
#     that means no: tput
#   more flexible input UI, non-interactive mode only
#     allow adding sessions directly
#   more convenient analysis UI, interactive mode only
#     since analysis is based on a unified file, there is no need to divide up a day at a certain cut-off time.

#### Constants #####
clock_fmt='%Y.%m.%d-%H:%M'
clock_user_facing_fmt='yyyy.mm.dd-HH:MM'

clock_synopsis_line1='clock'
clock_synopsis_line2='help [ error ]'
clock_synopsis_line3='in <tag> [ { minus <minutes> } | { at <timestamp> } ]'
clock_synopsis_line4='out <tag> [ { minus <minutes> } | { at <timestamp> } ] [ on <description> ]'
clock_synopsis_line5='switch <tag> [ on <description> ]'
clock_synopsis_line6='add <tag> for <minutes> [ { minus <minutes> } | { at <timestamp> } ] [ on <description> ]'
clock_synopsis_line7='extend [ { minus <minutes } | { at <timestamp> } ]'
clock_synopsis_line8='remove | pop'
clock_synopsis_line9='{ pause | p } | { resume | r }'
clock_synopsis_line10='log'
clock_synopsis_line11='last | l'
clock_synopsis_line12='past { dtn | day | week } | { <number> { days | weeks } } [ minus <number> hour(s) ]'

read -d '' CLOCK_SYN_VAR << CLOCK_SYN_DOC
${clock_synopsis_line1}   [ ${clock_synopsis_line2} ]
        [ ${clock_synopsis_line3} ]
        [ ${clock_synopsis_line4} ]
        [ ${clock_synopsis_line5} ]
        [ ${clock_synopsis_line6} ]
        [ ${clock_synopsis_line7} ]
        [ ${clock_synopsis_line8} ]
        [ ${clock_synopsis_line9} ]
        [ ${clock_synopsis_line10} ]
        [ ${clock_synopsis_line11} ]
        [ ${clock_synopsis_line12} ]
CLOCK_SYN_DOC

CLOCK_HEADER='end time,tag,length,description'

read -d '' CLOCK_MAN_VAR << CLOCK_MAN_DOC
NAME
     clock - clock in & out of work

SYNOPSIS
     ${clock_synopsis_line1}   [ ${clock_synopsis_line2} ]
             [ ${clock_synopsis_line3} ]
             [ ${clock_synopsis_line4} ]
             [ ${clock_synopsis_line5} ]
             [ ${clock_synopsis_line6} ]
             [ ${clock_synopsis_line7} ]
             [ ${clock_synopsis_line8} ]
             [ ${clock_synopsis_line9} ]
             [ ${clock_synopsis_line10} ]
             [ ${clock_synopsis_line11} ]
             [ ${clock_synopsis_line12} ]

DESCRIPTION
   
     clock lets you clock in and out of work, tracking how many minutes you've spent working each day.
   
     Options include:
   
     ${clock_synopsis_line2}
             Print help page. Optionally add 'error' to see the error codes.
   
     ${clock_synopsis_line3}
             Clock in to work labeled with a single-word <tag>. The <tag> is of the form <top>[.<nextLevel>*] where <top> is a top-level tag and <nextLevel> are next-level tags under the <top> tag. At summary time (see 'past' option), <top> tags are summarized in a dedicated section. Optionally specify the number of <minutes> ago at which the clock in happened. Clock automatically calculates the number of minutes in the session and records it to the log. Clock always records time in the locally-set time zone. Behind the scenes, clocking in adds a temporary record of the starting time and tag for a session in the format 'started,start time,tag,paused minutes,paused time' where 'started' is simply a keyword. 

     ${clock_synopsis_line4}
             Clock out from work labeled with a single-word <tag>. See 'in' option above for the <tag> format. Optionally specify either the number of <minutes> ago or the <timestamp> at which the session ended. The <timestamp> should be in the format '${clock_user_facing_fmt}'. Optionally specify what you worked on by typing 'on' followed by a sequence of words without any comma. Note that the 'on' suboption must be the last suboption passed in, as all subsequent words are parsed as a part of the description. Clock automatically calculates the number of minutes in the session and records it to the log. The clock-in record is overridden upon clocking out by a permanent record of the format '${CLOCK_HEADER}'.

     ${clock_synopsis_line5}
             As syntactic sugar, the 'switch' option clocks out of the current session and clocks in to a new session in <tag> at the same time. Optionally specify what you worked on in the previous session by typing 'on' followed by a sequence of words without any comma. Note that the 'on' suboption must be the last suboption passed in, as all subsequent words are parsed as a part of the description.
   
     ${clock_synopsis_line6}
             Manually add a session of <minutes> length to the log, ending at the time of command call. Optionally specify either the number of <minutes> ago or the <timestamp> at which the session ended. The <timestamp> should be in the format '${clock_user_facing_fmt}'. Optionally specify what you worked on by typing 'on' followed by a sequence of words without any comma. Note that the 'on' suboption must be the last suboption passed in, as all subsequent words are parsed as a part of the description. 
   
     ${clock_synopsis_line7}
             Extend the last session (only if complete) record in the log to the current time or, optionally, to an earlier time as specified by minus <minutes> or at <timestamp>.

     ${clock_synopsis_line8}
             Remove the last session record, whether incomplete or complete, and see what was removed. A synonym for 'remove' is 'pop'.
   
     ${clock_synopsis_line9}
             Pause or resume the current session. Behind the scenes, 'pause' updates the 'paused time' field to the current timestamp, while 'resume' clears the 'paused time' field and updates the 'paused minutes' field as appropriate.

     ${clock_synopsis_line10}
             Open the clock log file itself. It is helpful for manually editing session details. The clock log records work sessions as rows. Its implicit header is '${CLOCK_HEADER}'.

     ${clock_synopsis_line11}
             Prints the last entry of the clock log.
   
     ${clock_synopsis_line12}
             Prints a useful summary of clock records over the past <number> of day(s) or week(s), grouping the results by tag. 'dtn' returns a summary of the day since midnight while 'day' returns a summary of the past 24 hours. If no <number> is given, the number is assumed to be 1. Optionally specify the starting point of the look-back summary via the 'minus <number> hour(s)' suboption.
CLOCK_MAN_DOC
   
read -d '' CLOCK_ERROR_VAR << CLOCK_ERROR_DOC
EXIT STATUS
   
     0       No error.
     1       Argument error.
     2       Log access / modification error.
     3       Incompatible operating system.
     4       Date conversion error.
     5       Invalid log state.
     6       Summarization failed.
CLOCK_ERROR_DOC

# Detect current operating system
current_os="$( uname )"
case $current_os in
	Linux|Darwin) : ;;
	*) printf "Clock doesn't know how to operate in the '$current_os' operating system.\n" >&2 && exit 3 ;;
esac

#### Help Page #####
if [ "$#" -eq 0 ]; then
	clear
	printf "\n${CLOCK_SYN_VAR}\n\n"
	exit
fi

if [ "$1" = 'help' ]; then
	clear
	printf "${CLOCK_MAN_VAR}\n\n"
	if [ -n "$2" ] && [ "$2" = 'error' ]; then
		printf "${CLOCK_ERROR_VAR}\n\n"
	fi
	exit	
fi

#### Parse & check input without performing functions #####
clock_subfunction="" # in, out, add, undo, log, review
clock_tag="" # any one-word alphanumeric
clock_minus_minutes="" # any positive integer
clock_at_timestamp="" # in clock_fmt
clock_for_minutes="" # any positive integer
clock_add_end_timestamp="" # in clock_fmt
clock_past_days="" # any positive integer
clock_past_minus_hours=0 # any positive integer; default to 0
clock_dtn="" # day-to-now toggle; default to empty

if [ -z "$1" ]; then printf "Missing option for clock\n" >&2 && exit 1; fi

case "$1" in
in|out|switch)
	clock_subfunction="$1"

	if [ -z "$2" ]; then printf "Missing <tag> in 'clock $1 <tag>'\n" >&2 && exit 1; fi

	clock_tag="$2"

	while [ -n "$3" ]; do
		case "$3" in
		minus)
			if [ -z "$4" ]; then printf "Missing <minutes> in 'clock $1 $2 $3 <minutes>'\n" >&2 && exit 1; fi
			if [ -n "$4" ] && ! printf '%s' "$4" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <minutes> in 'clock $1 $2 $3 <minutes>'\n" >&2 && exit 1; fi
			clock_minus_minutes=$4
			shift; shift; # consume minus <minutes>
			;;

		at)
			if [ -z "$4" ]; then printf "Missing <timestamp> in 'clock $1 $2 $3 <timestamp>'\n" >&2 && exit 1; fi
			if [ -n "$4" ] && ! printf '%s' "$4" | grep -Eq '^[0-9]{4}\.[0-9]{2}\.[0-9]{2}-[0-9]{2}:[0-9]{2}$'; then printf "Please provide a valid timestamp in the format '${clock_user_facing_fmt}' for <timestamp> in 'clock $1 $2 $3 <timestamp>'\n" >&2 && exit 1; fi
			clock_at_timestamp="$4"
			shift; shift; # consume at <timestamp>
			;;

		on)
			if [ "$1" = 'in' ]; then printf "Unknown suboption '$3' after 'clock $1 $2'\n" >&2 && exit 1; fi
			if [ -z "$4" ]; then printf "Missing <description> in 'clock $1 $2 $3 <description>'\n" >&2 && exit 1; fi
			description_args="${@:4}"
			if [ -n "${description_args}" ] && printf '%s' "${description_args}" | grep -q ','; then printf "Please provide a valid description that does not include a comma for <description> in 'clock $1 $2 $3 <description>'\n" >&2 && exit 1; fi
			if [ -n "${description_args}" ] && printf '%s' "${description_args}" | grep -Eq '^minus|at$'; then printf "Please provide a valid description that does not include 'minus' or 'at' in 'clock $1 $2 $3 <description>'\n" >&2 && exit 1; fi
			clock_on_description="${description_args}"
			break; # after on, do not process any more suboptions
			;;
		
		*) 	printf "Unknown suboption '$3' after 'clock $1 $2'\n" >&2 && exit 1
			;;
		esac
	done

	;;

extend)
	clock_subfunction="$1"
	
	if [ -n "$2" ]; then
		case "$2" in
		minus)
			if [ -z "$3" ]; then printf "Missing <minutes> in 'clock $1 $2 <minutes>'\n" >&2 && exit 1; fi
			if [ -n "$3" ] && ! printf '%s' "$3" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <minutes> in 'clock $1 $2 <minutes>'\n" >&2 && exit 1; fi
			clock_minus_minutes=$3
			;;

		at)
			if [ -z "$3" ]; then printf "Missing <timestamp> in 'clock $1 $2 <timestamp>'\n" >&2 && exit 1; fi
			if [ -n "$3" ] && ! printf '%s' "$3" | grep -Eq '^[0-9]{4}\.[0-9]{2}\.[0-9]{2}-[0-9]{2}:[0-9]{2}$'; then printf "Please provide a valid timestamp in the format '${clock_user_facing_fmt}' for <timestamp> in 'clock $1 $2 <timestamp>'\n" >&2 && exit 1; fi
			clock_at_timestamp="$3"
			;;

		*) 	printf "Unknown suboption '$2' after 'clock $1'\n" >&2 && exit 1
			;;
		esac
	fi
	;;

add)
	clock_subfunction="$1"
	
	if [ -z "$2" ]; then printf "Missing <tag> in 'clock $1 <tag> for <minutes>'\n" >&2 && exit 1; fi

	clock_tag="$2"

	if [ -z "$3" ]; then printf "Missing 'for' keyword in 'clock $1 $2 for <minutes>'\n" >&2 && exit 1; fi
	if [ "$3" != 'for' ]; then printf "Expecting 'for <minutes>' as in 'clock $1 $2 for <minutes>'\n" >&2 && exit 1; fi

	case "$3" in
	for)
		if [ -z "$4" ]; then printf "Missing <minutes> in 'clock $1 $2 $3 <minutes>'\n" >&2 && exit 1; fi
		if [ -n "$4" ] && ! printf '%s' "$4" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <minutes> in 'clock $1 $2 $3 <minutes>'\n" >&2 && exit 1; fi
		clock_for_minutes="$4"

		while [ -n "$5" ]; do
			case "$5" in
			minus)
				if [ -z "$6" ]; then printf "Missing <minutes> in 'clock $1 $2 $3 $4 $5 <minutes>'\n" >&2 && exit 1; fi
				if ! printf '%s' "$6" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <minutes> in 'clock $1 $2 $3 $4 $5 <minutes>'\n" >&2 && exit 1; fi
				clock_minus_minutes=$6
				shift; shift; # consume minus <minutes>
				;;

			at)
				if [ -z "$6" ]; then printf "Missing <timestamp> in 'clock $1 $2 $3 $4 $5 <timestamp>'\n" >&2 && exit 1; fi
				if ! printf '%s' "$6" | grep -Eq '^[0-9]{4}\.[0-9]{2}\.[0-9]{2}-[0-9]{2}:[0-9]{2}$'; then printf "Please provide a valid timestamp in the format '${clock_user_facing_fmt}' for <timestamp> in 'clock $1 $2 $3 $4 $5 <timestamp>'\n" >&2 && exit 1; fi
				clock_add_end_timestamp="$6"
				shift; shift; # consume at <timestamp>
				;;

			on)
				if [ -z "$6" ]; then printf "Missing <description> in 'clock $1 $2 $3 $4 $5 <description>'\n" >&2 && exit 1; fi
				description_args="${@:6}"
				if [ -n "${description_args}" ] && printf '%s' "${description_args}" | grep -q ','; then printf "Please provide a valid description that does not include a comma for <description> in 'clock $1 $2 $3 $4 $5 <description>'\n" >&2 && exit 1; fi
				if [ -n "${description_args}" ] && printf '%s' "${description_args}" | grep -Eq '^minus|at$'; then printf "Please provide a valid description that does not include 'minus' or 'at' in 'clock $1 $2 $3 $4 $5 <description>'\n" >&2 && exit 1; fi
				clock_add_on_description="${description_args}"
				break; # after on, do not process any more suboptions
				;;

			*) 	printf "Unknown suboption '$5' after 'clock $1 $2 $3 $4'\n" >&2 && exit 1
				;;
			esac
		done

		;;

	*) 	printf "Unknown suboption '$3' after 'clock $1 $2'\n" >&2 && exit 1
		;;
	esac

	;;

remove|pop|pause|p|resume|r|log|last|l)
	if [ "$#" -gt 1 ]; then
		printf "Too many arguments. Usage: 'clock $1'\n"
		exit 1
	fi
	
	clock_subfunction="$1"

	case "${clock_subfunction}" in
	p) clock_subfunction='pause' ;;
	r) clock_subfunction='resume' ;;
	esac
	;;

past)
	clock_subfunction="$1"

	if [ -z "$2" ]; then printf "Missing second word in '${clock_synopsis_line12}'\n" >&2 && exit 1; fi

	case "$2" in
	dtn|day|week)
		case "$2" in
		dtn) clock_dtn=true ;;
		day) clock_past_days=1 ;;
		week) clock_past_days=7 ;;
		esac

		if [ -n "$3" ]; then
			case "$3" in
			minus)
				if [ -z "$4" ]; then printf "Missing <number> in 'clock $1 $2 $3 <number> hour(s)'\n" >&2 && exit 1; fi
				if ! printf '%s' "$4" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <number> in 'clock $1 $2 $3 <number> hour(s)'\n" >&2 && exit 1; fi

				if [ -z "$5" ]; then printf "Missing hour(s) keyword after 'clock $1 $2 $3 $4'\n" >&2 && exit 1; fi
				case "$5" in
				hour|hours)
					clock_past_minus_hours="$4"
					;;
				*) printf "Unknown suboption '$5' after 'clock $1 $2 $3 $4'\n" >&2 && exit 1
					;;
				esac
				;;

			*) 	printf "Unknown suboption '$3' after 'clock $1 $2'\n" >&2 && exit 1
				;;
			esac
		fi
		;;
	*)
		if printf '%s' "$2" | grep -Eq '^[0-9]+$'; then

			if [ -z "$3" ]; then printf "Missing 'days' or 'weeks' keyword after 'clock $1 $2'\n" >&2 && exit 1; fi

			case "$3" in
			days) 
				clock_past_days="$2"
				;;
			weeks)
				clock_past_days="$(( $2 * 7 ))"
				;;
			*) printf "Unknown suboption '$3' after 'clock $1 $2'\n" >&2 && exit 1
				;;
			esac

			if [ -n "$4" ]; then
				case "$4" in
				minus)
					if [ -z "$5" ]; then printf "Missing <number> in 'clock $1 $2 $3 $4 <number> hour(s)'\n" >&2 && exit 1; fi
					if ! printf '%s' "$5" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <number> in 'clock $1 $2 $3 $4 <number> hour(s)'\n" >&2 && exit 1; fi

					if [ -z "$6" ]; then printf "Missing hour(s) keyword after 'clock $1 $2 $3 $4 $5'\n" >&2 && exit 1; fi
					case "$6" in
					hour|hours)
						clock_past_minus_hours="$5"
						;;
					*) printf "Unknown suboption '$6' after 'clock $1 $2 $3 $4 $5'\n" >&2 && exit 1
						;;
					esac
					;;

				*) 	printf "Unknown suboption '$4' after 'clock $1 $2 $3'\n" >&2 && exit 1
					;;
				esac
			fi

		else
			printf "Unknown suboption '$2' after 'clock $1'\n" >&2 && exit 1
		fi
		;;
	esac
	;;

*)	printf "Unknown option '$1' after 'clock'\n" >&2 && exit 1
;;
esac

#### Make sure clock log exists ####
clock_dir="${XDG_DATA_HOME:-$HOME/.local/share}/clock"
if ! [ -d "$clock_dir" ]; then
	printf "Creating clock log directory at %s\n" "$clock_dir"
	mkdir -p "$clock_dir"
fi
clock_log=${clock_dir}/clock.csv
if ! [ -f $clock_log ]; then 
	printf "Creating clock log file\n"
	touch $clock_log
fi
## Ensure that the clock log always ends with the last non-empty line ##
clock_log_tmp=${clock_log}.tmp
# -s checks for file size > 0
while
	[ -s "$clock_log" ] && 
	last_line=$(tail -1 "$clock_log") &&
	[ -z "$last_line" ] || 
	printf '%s' "$last_line" | grep -Eq '^ *$' ||
	printf '%s' "$last_line" | grep -Eq '^	$'
do
	if [ $( wc -l "$clock_log" | cut -d' ' -f1 ) -eq 1 ]; then
		printf "\nClearing clock log of unaccounted-for control characters\n"
		> "$clock_log"
	else
		printf "\nRemoving trailing blank line in clock log\n"
		sed -e '$d' "$clock_log" > $clock_log_tmp || exit 2
		mv $clock_log_tmp $clock_log || exit 2
	fi
done
# At this point the last_line variable should hold the last line content.

#### Perform log validity check for in, extend, add, past ####
if [ "$clock_subfunction" = 'in' ] || [ "$clock_subfunction" = 'extend' ] || [ "$clock_subfunction" = 'add' ] || [ "$clock_subfunction" = 'past' ] ; then
	# If file is empty skip this guard. 
	# If file is non-empty and last line is still in 'started' format, then interactively prompt user to give a session length for the started session or remove the partial record.
	if [ -n "$last_line" ] && [ "$(printf "$last_line" | cut -d, -f1)" = 'started' ]; then
		start_timestamp="$(printf "$last_line" | cut -d, -f2)"
		start_tag="$(printf "$last_line" | cut -d, -f3)"

		# first exit early if 'extend' option, since we want to prevent unintended behavior
		if [ "$clock_subfunction" = 'extend' ]; then
			printf "Cannot extend when there is still an ongoing session in\n  %s\n  that started at\n  %s\n" "${start_tag}" "${start_timestamp}"
			exit 1
		fi

		repeat_prompt='true'
		while [ "$repeat_prompt" = 'true' ]; do
			
			printf "\nPlease provide a length in minutes for the session in\n  ${start_tag}\n  that began at\n  ${start_timestamp}\nor type 'r' to remove the record.\n\n"
			read -p "Session length: " user_input_session_mins

			if [ "$user_input_session_mins" = 'r' ]; then
				sed -e '$d' $clock_log > $clock_log_tmp || exit 2
				mv $clock_log_tmp $clock_log || exit 2
				printf "\nRemoved partial record\n"
				printf "  ${last_line}\n"
				repeat_prompt='false'

			elif printf '%s' "$user_input_session_mins" | grep -Eq '^[0-9]+$'; then
				# Calculate end timestamp based on start timestamp and user-provided session length
				end_timestamp=""
				case "$current_os" in
					Linux)
						# timestamp format in clock_fmt
						start_epochtime="$( date -d "$start_timestamp" +'%s' )" || exit 4
						end_epochtime="$(( $start_epochtime + $user_input_session_mins * 60 ))"
						end_timestamp="$( date -d @"$end_epochtime" +$clock_fmt )" || exit 4
						;;
					Darwin)
						end_timestamp="$( date -j -v+${user_input_session_mins}M -f $clock_fmt "$start_timestamp" +$clock_fmt )" || exit 4
						;;
				esac

				new_record="${end_timestamp},${start_tag},${user_input_session_mins}"
				sed -e '$d' $clock_log > $clock_log_tmp || exit 2
				printf "${new_record}\n" >> $clock_log_tmp || exit 2
				mv $clock_log_tmp $clock_log || exit 2

				printf "\nReplaced partial session with a full session in\n  ${start_tag}\n  that was active for\n  ${user_input_session_mins} minutes\n  and ended at\n  ${end_timestamp}.\n"

				printf "\nIn addition:\n"

				repeat_prompt='false'

			else
				printf "\nInvalid user input '$user_input_session_mins'. Please try again.\n"
			fi

		done

	fi

fi

#### Perform 'in' option ####
# Note that pre-in log validity check has already been performed
if [ "$clock_subfunction" = 'in' ]; then
	## Add 'in' portion of session to log ##
	# if needed, calculate adjusted timestamp for start time
	start_timestamp=""
	if [ -n "$clock_at_timestamp" ]; then
		start_timestamp="$clock_at_timestamp"
	else
		if [ -n "$clock_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clock_minus_minutes * 60 ))
					start_timestamp="$( date -d @$adjusted_epochtime +$clock_fmt )"
					;;
				Darwin)
					start_timestamp="$(date -v -${clock_minus_minutes}M +$clock_fmt)"
					;;
			esac
		else
			start_timestamp="$(date +$clock_fmt)"
		fi
	fi

	total_paused_minutes=0
	last_paused_at=""

	printf "started,${start_timestamp},${clock_tag},${total_paused_minutes},${last_paused_at}\n" >> $clock_log &&
		printf "\nAdded new session in\n  ${clock_tag}\n  that started at\n  ${start_timestamp}\n" ||
		exit 2
	
	printf '\n'
	exit 0
fi

#### Perform 'extend' option ####
# With minor tweaks, this is a copy-and-paste from clock-out subfunction.
if [ "$clock_subfunction" = 'extend' ]; then
	# Guard-check that the file is non-empty
	if [ -z "$last_line" ]; then
		printf "Clock log is empty. Cannot extend last session.\n" >&2 && exit 5
	fi

	# Calculate adjusted timestamp for extended_end_timestamp
	extended_end_timestamp=""
	if [ -n "$clock_at_timestamp" ]; then
		extended_end_timestamp="$clock_at_timestamp"
	else
		if [ -n "$clock_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clock_minus_minutes * 60 ))
					extended_end_timestamp="$( date -d @$adjusted_epochtime +$clock_fmt )"
					;;
				Darwin)
					extended_end_timestamp="$(date -v -${clock_minus_minutes}M +$clock_fmt)"
					;;
			esac
		else
			extended_end_timestamp="$(date +$clock_fmt)"
		fi
	fi

	# Obtain previous end-timestamp
	prev_end_timestamp="$(printf "$last_line" | cut -d, -f1)"

	# Calculate session extension length based on (adjusted) end timestamp and last sesh end timestamp
	prev_end_epochtime=""
	extended_end_epochtime=""
	case "$current_os" in
		Linux)
			# timestamp format in clock_fmt
			prev_end_epochtime="$( date -d "$prev_end_timestamp" +'%s' )" || exit 4
			extended_end_epochtime="$( date -d "$extended_end_timestamp" +'%s' )" || exit 4
			;;
		Darwin)
			prev_end_epochtime="$( date -j -f $clock_fmt "$prev_end_timestamp" +'%s' )" || exit 4
			extended_end_epochtime="$( date -j -f $clock_fmt "$extended_end_timestamp" +'%s' )" || exit 4
			;;
	esac

	difference_in_seconds=$(( $extended_end_epochtime - $prev_end_epochtime ))

	# if the difference is negative, inform the user end time is invalid.
	if printf '%s' "$difference_in_seconds" | grep -Eq '^-'; then
		printf "Clock-extend time\n  ${extended_end_timestamp}\n  cannot be earlier than previous clock-out time\n  ${prev_end_timestamp}\n" && exit 1
	fi

	# Obtain previous length & calculate extended length
	prev_length="$(printf "$last_line" | cut -d, -f3)"
	extension_length=$(( $difference_in_seconds / 60 ))
	updated_length=$(( $prev_length + $extension_length ))

	# obtain previous session tag
	prev_sesh_tag="$(printf "$last_line" | cut -d, -f2)"

	# obtain previous session description
	prev_sesh_desc="$(printf "$last_line" | cut -d, -f4)"

	# Replace last completed-session record with new completed-session record
	new_record="${extended_end_timestamp},${prev_sesh_tag},${updated_length},${prev_sesh_desc}"
	sed -e '$d' $clock_log > $clock_log_tmp || exit 2
	printf "${new_record}\n" >> $clock_log_tmp || exit 2
	mv $clock_log_tmp $clock_log || exit 2

	# set description string
	description_string=""
	if [ -n "${prev_sesh_desc}" ]; then
		description_string="  on ${prev_sesh_desc}"
		description_string+=$'\n'
	fi

	printf "\nExtended last session in\n  %s\n%s  by\n  %s minutes\n  for a total session length of\n  %d minutes\n  ending at\n  %s.\n" "${prev_sesh_tag}" "${description_string}" "${extension_length}" "${updated_length}" "${extended_end_timestamp}"

	printf '\n'
	exit 0
fi

#### Perform log validity check for out, switch, pause, resume ####
if [ "$clock_subfunction" = 'out' ] || [ "$clock_subfunction" = 'switch' ] || [ "$clock_subfunction" = 'pause' ] || [ "$clock_subfunction" = 'resume' ] ; then
	# If file is empty, or 
	# if file is non-empty and last line is NOT in 'started' format, then quit and ask user to clock in first.
	if [ -z "$last_line" ] || ! [ "$(printf "$last_line" | cut -d, -f1)" = 'started' ]; then
		printf "No latest clock-in record found. Please clock in first.\n" >&2 && exit 5
	fi
fi

#### Perform 'out' option ####
if [ "$clock_subfunction" = 'out' ]; then
	## Guard - Check if latest partial record has the same tag ##
	start_tag="$(printf "$last_line" | cut -d, -f3)"
	if ! [ "$clock_tag" = "$start_tag" ]; then
		printf "The clock-out work tag '$clock_tag' does not match the clock-in work tag '$start_tag'\n" >&2 && exit 1
	fi

	## Add 'out' portion of session to log ##
	# if needed, calculate adjusted timestamp for end time
	end_timestamp=""
	if [ -n "$clock_at_timestamp" ]; then
		end_timestamp="$clock_at_timestamp"
	else
		if [ -n "$clock_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clock_minus_minutes * 60 ))
					end_timestamp="$( date -d @$adjusted_epochtime +$clock_fmt )"
					;;
				Darwin)
					end_timestamp="$(date -v -${clock_minus_minutes}M +$clock_fmt)"
					;;
			esac
		else
			end_timestamp="$(date +$clock_fmt)"
		fi
	fi

	# calculate session length based on (adjusted) end timestamp and start timestamp
	start_timestamp="$(printf "$last_line" | cut -d, -f2)"
	start_epochtime=""
	end_epochtime=""
	case "$current_os" in
		Linux)
			# timestamp format in clock_fmt
			start_epochtime="$( date -d "$start_timestamp" +'%s' )" || exit 4
			end_epochtime="$( date -d "$end_timestamp" +'%s' )" || exit 4
			;;
		Darwin)
			start_epochtime="$( date -j -f $clock_fmt "$start_timestamp" +'%s' )" || exit 4
			end_epochtime="$( date -j -f $clock_fmt "$end_timestamp" +'%s' )" || exit 4
			;;
	esac

	difference_in_seconds=$(( $end_epochtime - $start_epochtime ))

	# if the difference is negative, inform the user end time is invalid.
	if printf '%s' "$difference_in_seconds" | grep -Eq '^-'; then
		printf "Clock-out time\n  ${end_timestamp}\n  cannot be earlier than clock-in time\n  ${start_timestamp}\n" && exit 1
	fi

	# now obtain and subtract paused minutes
	paused_minutes="$( printf "$last_line" | cut -d, -f4 )"
	no_pause_session_length=$(( $difference_in_seconds / 60 ))
	session_length=$(( $no_pause_session_length - $paused_minutes ))

	# if the session length is negative due to too many paused minutes, inform the user end time is invalid.
	if printf '%s' "$session_length" | grep -Eq '^-'; then
		printf 'Current session paused minutes of %d\n  cannot exceed total session length of %d.\n' ${paused_minutes} ${no_pause_session_length} && exit 1
	fi

	# Replace start-session record with completed-session record
	new_record="${end_timestamp},${clock_tag},${session_length},${clock_on_description}"
	sed -e '$d' $clock_log > $clock_log_tmp || exit 2
	printf "${new_record}\n" >> $clock_log_tmp || exit 2
	mv $clock_log_tmp $clock_log || exit 2

	paused_string=""
	if [ "$paused_minutes" -gt 0 ]; then
		paused_string="was paused for"
		paused_string+=$'\n'
		paused_string+="  ${paused_minutes} minutes"
		paused_string+=$'\n  and '
	fi

	# set description string
	description_string=""
	if [ -n "$clock_on_description" ]; then
		description_string="  on ${clock_on_description}"
		description_string+=$'\n'
	fi

	printf "\nRecorded full session in\n  %s\n  starting at\n  %s\n%s  that %swas active for\n  %d minutes\n  and ended at\n  %s.\n" "${clock_tag}" "${start_timestamp}" "${description_string}" "${paused_string}" "${session_length}" "${end_timestamp}"

	printf '\n'
	exit 0
fi

### Perform 'switch' option ####
# The first half of this procedure copies from clock out (excluding the same-tag guard); the second half copies from clock in.
if [ "$clock_subfunction" = 'switch' ]; then

	# if needed, calculate adjusted timestamp for switch time
	switch_timestamp=""
	if [ -n "$clock_at_timestamp" ]; then
		switch_timestamp="$clock_at_timestamp"
	else
		if [ -n "$clock_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clock_minus_minutes * 60 ))
					switch_timestamp="$( date -d @$adjusted_epochtime +$clock_fmt )"
					;;
				Darwin)
					switch_timestamp="$(date -v -${clock_minus_minutes}M +$clock_fmt)"
					;;
			esac
		else
			switch_timestamp="$(date +$clock_fmt)"
		fi
	fi

	## Add previous session to log ##
	# calculate previous session length based on (adjusted) end timestamp and prev sesh start timestamp
	prev_sesh_start_timestamp="$(printf "$last_line" | cut -d, -f2)"
	start_epochtime=""
	end_epochtime=""
	case "$current_os" in
		Linux)
			# timestamp format in clock_fmt
			start_epochtime="$( date -d "$prev_sesh_start_timestamp" +'%s' )" || exit 4
			end_epochtime="$( date -d "$switch_timestamp" +'%s' )" || exit 4
			;;
		Darwin)
			start_epochtime="$( date -j -f $clock_fmt "$prev_sesh_start_timestamp" +'%s' )" || exit 4
			end_epochtime="$( date -j -f $clock_fmt "$switch_timestamp" +'%s' )" || exit 4
			;;
	esac

	difference_in_seconds=$(( $end_epochtime - $start_epochtime ))

	# if the difference is negative, inform the user end time is invalid.
	if printf '%s' "$difference_in_seconds" | grep -Eq '^-'; then
		printf "Clock-switch time\n  ${switch_timestamp}\n  cannot be earlier than previous session's clock-in time\n  ${prev_sesh_start_timestamp}\n" && exit 1
	fi

	session_length=$(( $difference_in_seconds / 60 ))

	# obtain previous session tag
	prev_sesh_tag="$(printf "$last_line" | cut -d, -f3)"

	# replace start-session record with completed-session record
	if [ -n "${clock_on_description}" ]; then
		new_record="${switch_timestamp},${prev_sesh_tag},${session_length},${clock_on_description}"
	else
		new_record="${switch_timestamp},${prev_sesh_tag},${session_length},"
	fi
	sed -e '$d' $clock_log > $clock_log_tmp || exit 2
	printf "${new_record}\n" >> $clock_log_tmp || exit 2
	mv $clock_log_tmp $clock_log || exit 2

	# set description string
	description_string=""
	if [ -n "$clock_on_description" ]; then
		description_string="  on ${clock_on_description}"
		description_string+=$'\n'
	fi

	printf "\nRecorded full session in\n  %s\n%s  that was active for\n  %d minutes\n  and ended at\n  %s.\n" "${prev_sesh_tag}" "${description_string}" "${session_length}" "${switch_timestamp}"

	## Add start of new session to log ##

	total_paused_minutes=0
	last_paused_at=""

	printf "started,${switch_timestamp},${clock_tag},${total_paused_minutes},${last_paused_at}\n" >> $clock_log &&
		printf "\nAdded new session in\n  ${clock_tag}\n  that started at\n  ${switch_timestamp}\n" ||
		exit 2
	
	printf '\n'
	exit 0
fi

#### Perform 'add' option ####
# Note that pre-add log validity check has already been performed
if [ "$clock_subfunction" = 'add' ]; then
	## Add full session to log ##
	# if needed, calculate adjusted timestamp for end time
	if [ -z "$clock_add_end_timestamp" ]; then
		clock_add_end_timestamp=""
		if [ -n "$clock_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clock_minus_minutes * 60 ))
					clock_add_end_timestamp="$( date -d @$adjusted_epochtime +$clock_fmt )"
					;;
				Darwin)
					clock_add_end_timestamp="$(date -v -${clock_minus_minutes}M +$clock_fmt)"
					;;
			esac
		else
			clock_add_end_timestamp="$(date +$clock_fmt)"
		fi
	fi

	# add record
	add_record="${clock_add_end_timestamp},${clock_tag},${clock_for_minutes},${clock_add_on_description}"
	printf "${add_record}\n" >> $clock_log || exit 2

	# set description string
	description_string=""
	if [ -n "$clock_add_on_description" ]; then
		description_string="  on ${clock_add_on_description}"
		description_string+=$'\n'
	fi

	printf "\nRecorded full session in\n  %s\n%s  that was active for\n  %d minutes\n  and ended at\n  %s\n" "${clock_tag}" "${description_string}" "${clock_for_minutes}" "${clock_add_end_timestamp}"

	printf '\n'
	exit 0
fi

#### Perform 'remove' or 'pop' option ####
if [ "$clock_subfunction" = 'remove' ] || [ "$clock_subfunction" = 'pop' ]; then
	clock_verb="${clock_subfunction}"
	## Guard - Check if current log is pre-remove valid ##
	if [ -z "$last_line" ]; then
		printf "No clock record found. Cannot ${clock_verb} any record.\n" >&2 && exit 5
	fi

	## Remove last log item & print it ##
	sed -e '$d' $clock_log > $clock_log_tmp || exit 2
	mv $clock_log_tmp $clock_log || exit 2
	if [ "$clock_subfunction" = 'remove' ]; then 
		clock_verb='Removed'
	elif [ "$clock_subfunction" = 'pop' ]; then
		clock_verb='Popped'
	fi
	printf "\n${clock_verb} record\n"
	printf "  ${last_line}\n"

	printf '\n'
	exit 0
fi

#### Perform 'pause' option ####
if [ "$clock_subfunction" = 'pause' ]; then
	# obtain existing fields
	start_timestamp="$(printf "$last_line" | cut -d, -f2)"
	current_sesh_tag="$(printf "$last_line" | cut -d, -f3)"
	current_sesh_paused_mins="$(printf "$last_line" | cut -d, -f4)"
	current_sesh_paused_time="$(printf "$last_line" | cut -d, -f5)"
	if [ -n "$current_sesh_paused_time" ]; then
		printf 'Cannot pause current session, as it was already paused at %s\n' "${current_sesh_paused_time}"
		exit 5
	fi
	# replace record with new one where paused time field is set to current timestamp
	pause_timestamp="$(date +$clock_fmt)"
	new_record="started,${start_timestamp},${current_sesh_tag},${current_sesh_paused_mins},${pause_timestamp}"
	sed -e '$d' $clock_log > $clock_log_tmp || exit 2
	printf "${new_record}\n" >> $clock_log_tmp || exit 2
	mv $clock_log_tmp $clock_log || exit 2
	# report the pause
	printf '\nThe current session in\n  %s\n  has been paused at\n  %s\n\n' "${current_sesh_tag}" "${pause_timestamp}"
	exit 0
fi

#### Perform 'resume' option ####
if [ "$clock_subfunction" = 'resume' ]; then
	## obtain existing fields
	start_timestamp="$(printf "$last_line" | cut -d, -f2)"
	sesh_tag="$(printf "$last_line" | cut -d, -f3)"
	sesh_prev_paused_mins="$(printf "$last_line" | cut -d, -f4)"
	if ! printf '%s' "${sesh_prev_paused_mins}" | grep -Eq '^[0-9]+$'; then
		printf 'Current session paused minutes field (4th field) is not an integer. Please fix in log.\n'
		exit 5
	fi
	paused_timestamp="$(printf "$last_line" | cut -d, -f5)"
	# obtain timestamp now
	now_timestamp="$(date +$clock_fmt)"

	## calculate new paused minutes	
	# calculate paused time as diff between current timestamp and paused timestamp
	paused_epochtime=""
	now_epochtime=""
	case "$current_os" in
			Linux)
					# timestamp format in clock_fmt
					paused_epochtime="$( date -d "$paused_timestamp" +'%s' )" || exit 4
					now_epochtime="$( date -d "$now_timestamp" +'%s' )" || exit 4
					;;
			Darwin)
					paused_epochtime="$( date -j -f $clock_fmt "$paused_timestamp" +'%s' )" || exit 4
					now_epochtime="$( date -j -f $clock_fmt "$now_timestamp" +'%s' )" || exit 4
					;;
	esac

	difference_in_seconds=$(( $now_epochtime - $paused_epochtime ))

	# if the difference is negative, inform the user end time is invalid.
	if printf '%s' "$difference_in_seconds" | grep -Eq '^-'; then
			printf "Resume time\n  ${now_timestamp}\n  cannot be earlier than paused time\n  ${paused_timestamp}\n" && exit 1
	fi
	# increment paused mins by new paused mins
	added_paused_mins=$(( ( $difference_in_seconds / 60 ) ))
	sesh_new_paused_mins=$(( $sesh_prev_paused_mins + $added_paused_mins ))

	## update record
	# update paused minutes and clear paused time field
	new_record="started,${start_timestamp},${sesh_tag},${sesh_new_paused_mins},"
	sed -e '$d' $clock_log > $clock_log_tmp || exit 2
	printf "${new_record}\n" >> $clock_log_tmp || exit 2
	mv $clock_log_tmp $clock_log || exit 2
	# report resume
	printf '\nThe current session in\n  %s\n  which was paused at\n  %s\n  for %s minutes\n  has been resumed.\n\n' "${sesh_tag}" "${paused_timestamp}" "${sesh_new_paused_mins}"
	exit 0
fi

#### Perform 'log' option ####
if [ "$clock_subfunction" = 'log' ]; then
	vi $clock_log
	exit 0
fi

#### Perform 'last' option ####
if [ "$clock_subfunction" = 'last' ] || [ "$clock_subfunction" = 'l' ]; then
	printf "${last_line}\n"
	exit 0
fi

#### Perform 'past' option ####
if [ "$clock_subfunction" = 'past' ]; then
	## Guard - Check if current log is pre-past valid ##
	if [ -z "$last_line" ]; then
		printf "No clock record found. Cannot perform summary.\n" >&2 && exit 5
	fi

	## Calculate cut-off epoch ##
	if ! [ "$clock_dtn" = 'true' ]; then
		clock_past_hours_with_minus=$(( $clock_past_days * 24 + $clock_past_minus_hours ))
	fi

	# printf >&2 "clock_past_hours_with_minus: $clock_past_hours_with_minus\n"
	# printf >&2 "clock_past_minus_hours: $clock_past_minus_hours\n"
	# exit
	case "$current_os" in
		Linux)
			current_epochtime="$(date +'%s')"
			if [ "$clock_dtn" = 'true' ]; then
				startcut_epochtime="$( date -d "$( date +'%Y.%m.%d-%H:%M:%S' )" +'%s' )"
				endcut_epochtime="$current_epochtime"
			else
				startcut_epochtime=$(( $current_epochtime - $clock_past_hours_with_minus * 3600 ))
				endcut_epochtime=$(( $current_epochtime - $clock_past_minus_hours * 3600 ))
			fi
			;;
		Darwin)
			if [ "$clock_dtn" = 'true' ]; then
				startcut_epochtime="$( date -j -f '%m-%d:%H:%M:%S' "$(date +%m-%d):00:00:00" +%s )"
				endcut_epochtime="$(date +%s)"
			else
				startcut_epochtime="$(date -v -${clock_past_hours_with_minus}H +'%s')"
				endcut_epochtime="$(date -v -${clock_past_minus_hours}H +'%s')"
			fi
			;;
	esac

	## Output a helpful summary of records after cut-off time ##
	# for a more efficient algorithm:
	#   first sort the records
	#   then search backwards using tail or tac and find the earliest in-startcut and the earliest in-endcut lines' timestamps
	#   then use those timestamps to make a non-filtering awk for the final aggregation operation.

	# sort the records
	sort $clock_log > $clock_log_tmp || exit 2
	mv $clock_log_tmp $clock_log || exit 2

	# search backwards using tail and find earliest in-startcut timestamp
	first_timestamp_of_all_time="$( head -1 $clock_log | cut -d, -f1 )"
	last_timestamp_of_all_time="$( tail -1 $clock_log | cut -d, -f1 )"

	earliest_post_startcut_line=""
	latest_pre_endcut_line=""

	# first check if endcut is before the first timestamp. if so, there's nothing to summarize.
	case "$current_os" in
		# zeroed_fmt is clock_fmt with a standardized 00 for seconds so that the converted epoch time is consistent across calls.
		# note that we can access record_epoch outside of the if condition because variables are globally scoped by default.
		Linux)
			# if the startcut is before the first timestamp, then just use the first timestamp
			first_epochtime="$( date -d "$first_timestamp_of_all_time" +'%s' )"
			last_epochtime="$( date -d "$last_timestamp_of_all_time" +'%s' )"
			if [ "$first_epochtime" -ge "$endcut_epochtime" ]; then
				printf 'Nothing to summarize: cutoff end-time precedes earliest timestamp in clock log\n'; exit 0
			elif [ "$last_epochtime" -lt "$startcut_epochtime" ]; then
				printf 'Nothing to summarize: cutoff start-time is later than latest timestamp in clock log\n'; exit 0
			elif [ "$first_epochtime" -ge "$startcut_epochtime" ]; then
				earliest_post_startcut_line="$first_timestamp_of_all_time"
			else
				earliest_post_startcut_line="$( \
					tac $clock_log | \
					awk -F, -v startcut="$startcut_epochtime" -v zeroed_fmt="${clock_fmt}:%S" \
						'{ \
							date_cmd = "date -d "$1":00 +%s"; \
							if ( ( date_cmd | getline record_epoch ) < 0 ) \
								{ print "Date conversion inside startcut search failed for timestamp " $1 > "/dev/stderr" ; exit 1; } \
							close(date_cmd); \
							if ( record_epoch > startcut ) \
								{ prev_timestamp = $1; prev_NR = NR; } \
							else \
								{ printf "%d,%s", prev_NR, prev_timestamp; exit; } \
						}' \
				)" || exit 1
			fi
			latest_pre_endcut_line="$( \
				tac $clock_log | \
				awk -F, -v endcut="$endcut_epochtime" -v zeroed_fmt="${clock_fmt}:%S" \
					'{ \
						date_cmd = "date -d "$1":00 +%s"; \
						if ( ( date_cmd | getline record_epoch ) < 0 ) \
							{ print "Date conversion inside endcut search failed for timestamp " $1 > "/dev/stderr" ; exit 1; } \
						close(date_cmd); \
						if ( record_epoch < endcut ) { printf "%d,%s", NR, $1; exit; } \
					}' \
			)" || exit 1

			;;

		Darwin)
			first_epochtime="$( date -j -f "$clock_fmt" "$first_timestamp_of_all_time" +'%s' )"
			last_epochtime="$( date -j -f "$clock_fmt" "$last_timestamp_of_all_time" +'%s' )"
			if [ "$first_epochtime" -ge "$endcut_epochtime" ]; then
				printf 'Nothing to summarize: cutoff end-time precedes earliest timestamp in clock log\n'; exit 0
			elif [ "$last_epochtime" -lt "$startcut_epochtime" ]; then
				printf 'Nothing to summarize: cutoff start-time is later than latest timestamp in clock log\n'; exit 0
			elif [ "$first_epochtime" -ge "$startcut_epochtime" ]; then
				earliest_post_startcut_line="$first_timestamp_of_all_time"
			else
				# printf >&2 "startcut_epochtime: $startcut_epochtime\n"
				# printf >&2 "%s\n" "clock_fmt: $clock_fmt"
				# it is CRUCIAL to close the command after each run, otherwise the pipe will fail after too many open files.
				earliest_post_startcut_line="$( \
					tail -r $clock_log | \
					awk -F, -v startcut="$startcut_epochtime" -v zeroed_fmt="${clock_fmt}:%S" \
						'{ \
							date_cmd = "date -j -f "zeroed_fmt" "$1":00 +%s"; \
							if ( ( date_cmd | getline record_epoch ) < 0 ) \
								{ print "Date conversion inside endcut search failed for timestamp " $1 > "/dev/stderr"; exit 1; } \
							close(date_cmd); \
							if ( record_epoch > startcut ) \
								{ prev_timestamp = $1; prev_NR = NR; } \
							else \
								{ printf "%d,%s", prev_NR, prev_timestamp; exit; } \
						}' \
				)" || exit 1
			fi
			latest_pre_endcut_line="$( \
				tail -r $clock_log | \
				awk -F, -v endcut="$endcut_epochtime" -v zeroed_fmt="${clock_fmt}:%S" \
					'{ \
						date_cmd = "date -j -f "zeroed_fmt" "$1":00 +%s"; \
						if ( ( date_cmd | getline record_epoch ) < 0 ) \
							{ print "Date conversion inside endcut search failed for timestamp " $1 > "/dev/stderr" ; exit 1; } \
						close(date_cmd); \
						if ( record_epoch < endcut ) { printf "%d,%s", NR, $1; exit; } \
					}' \
			)" || exit 1
			;;
	esac

	# check variables
	# printf >&2 "endcut_epochtime: $endcut_epochtime\n"
	# printf >&2 "earliest_post_startcut_line: $earliest_post_startcut_line\n"
	# printf >&2 "latest_pre_endcut_line: $latest_pre_endcut_line\n"

	# obtain the line-number fields for each line.
	earliest_post_startcut_linenum="${earliest_post_startcut_line%,*}"
	latest_pre_endcut_linenum="${latest_pre_endcut_line%,*}"

	# guard-check that earliest line is not _after_ latest line, which would mean the time range is negative and summary should be empty. since the awk results are based on reverse-files, we early-exit if earliest linenum is less than latest linenum, indicating that earliest linenum actually comes _after_ latest linenum in right order.
	if [ $earliest_post_startcut_linenum -le $latest_pre_endcut_linenum ]; then
		printf 'No clock records found within the desired time range.\n' >&2 && exit 0
	fi

	# obtain timestamps
	earliest_post_startcut_timestamp="${earliest_post_startcut_line#*,}"
	latest_pre_endcut_timestamp="${latest_pre_endcut_line#*,}"


	if [ -z "$earliest_post_startcut_timestamp" ]; then
		printf "No clock records found after the desired time range start time.\n" >&2 && exit 0
	elif [ -z "$latest_pre_endcut_timestamp" ]; then
		printf "No clock records found before the desired time range end time.\n" >&2 && exit 0
	fi
	
	# using the startcut and endcut timestamps, give summary of the right records
	# note that because of the sort command at the end, the ordering of your output will be determined by the sort and not by awk.
	# note that split("", arr) is used to clear an arr
	printf "\n-- Top-level tags --\n"
	awk -F, -v earliest_match="$earliest_post_startcut_timestamp" \
			-v latest_match="$latest_pre_endcut_timestamp" \
		'$0 ~ earliest_match, $0 ~ latest_match \
			{ 	\
				split("", tag_components); \
				split($2, tag_components, "."); \
				TOP[tag_components[1]]+=$3; \
				total+=$3; \
			} \
		END { \
			printf "%-17s%-7d%7.2fh\n", "TOTAL", total, (total/60); \
			for (tl in TOP) printf "%-17s%-7d%7.2fh   %06.3f%%\n", tl, TOP[tl], (TOP[tl]/60), TOP[tl]/total*100; \
		}' $clock_log | \
	sort -k2 -n -r || exit 6

	printf "\n-- Original tags --\n"
	awk -F, -v earliest_match="$earliest_post_startcut_timestamp" \
			-v latest_match="$latest_pre_endcut_timestamp" \
	'$0 ~ earliest_match, $0 ~ latest_match \
		{ 	\
			TAG[$2]+=$3; \
			total+=$3; \
		} \
	END { \
		printf "%-17s%-7d%7.2fh\n", "TOTAL", total, (total/60); \
		for (t in TAG) printf "%-17s%-7d%7.2fh   %06.3f%%\n", t, TAG[t], (TAG[t]/60), TAG[t]/total*100; \
	}' $clock_log | \
	sort -k2 -n -r || exit 6

	printf '\n'
	exit 0
fi


