#!/usr/bin/env bash
# clk v2
#   single unified tsv for easier analysis & porting to other apps
#   minimal POSIX-set sh-compliant instead of zsh so as to enable mobile recording on iSH with ash on iPhone (when porting to iSH, change the shebang to ash.)
#     does not use shebang since it should work on both zsh (Mac) and ash (iSH)
#   no fancy stuff not found in busybox
#     that means no: tput
#   more flexible input UI, non-interactive mode only
#     allow adding sessions directly
#   more convenient analysis UI, interactive mode only
#     since analysis is based on a unified file, there is no need to divide up a day at a certain cut-off time.

#### Constants #####
clk_fmt='%Y.%m.%d-%H:%M'
clk_user_facing_fmt='yyyy.mm.dd-HH:MM'

clk_synopsis_line1='clk'
clk_synopsis_line2='help [ error ]'
clk_synopsis_line3='in <tag> [ { minus <minutes> } | { at <timestamp> } ]'
clk_synopsis_line4='out <tag> [ { minus <minutes> } | { at <timestamp> } ] [ on <description> ]'
clk_synopsis_line5='switch <tag> [ on <description> ]'
clk_synopsis_line6='add <tag> for <minutes> [ { minus <minutes> } | { at <timestamp> } ] [ on <description> ]'
clk_synopsis_line7='extend [ { minus <minutes } | { at <timestamp> } ]'
clk_synopsis_line8='remove | pop'
clk_synopsis_line9='{ pause | p } | { resume | r }'
clk_synopsis_line10='log'
clk_synopsis_line11='last | l'
clk_synopsis_line12='past { dtn | day | week } | { <number> { days | weeks } } [ minus <number> hour(s) ]'

read -d '' CLK_SYN_VAR << CLK_SYN_DOC
${clk_synopsis_line1}   [ ${clk_synopsis_line2} ]
        [ ${clk_synopsis_line3} ]
        [ ${clk_synopsis_line4} ]
        [ ${clk_synopsis_line5} ]
        [ ${clk_synopsis_line6} ]
        [ ${clk_synopsis_line7} ]
        [ ${clk_synopsis_line8} ]
        [ ${clk_synopsis_line9} ]
        [ ${clk_synopsis_line10} ]
        [ ${clk_synopsis_line11} ]
        [ ${clk_synopsis_line12} ]
CLK_SYN_DOC

CLK_TAB='	'
CLK_HEADER="end time${CLK_TAB}tag${CLK_TAB}length${CLK_TAB}description"

read -d '' CLK_MAN_VAR << CLK_MAN_DOC
NAME
     clk - clock in & out of work

SYNOPSIS
     ${clk_synopsis_line1}   [ ${clk_synopsis_line2} ]
             [ ${clk_synopsis_line3} ]
             [ ${clk_synopsis_line4} ]
             [ ${clk_synopsis_line5} ]
             [ ${clk_synopsis_line6} ]
             [ ${clk_synopsis_line7} ]
             [ ${clk_synopsis_line8} ]
             [ ${clk_synopsis_line9} ]
             [ ${clk_synopsis_line10} ]
             [ ${clk_synopsis_line11} ]
             [ ${clk_synopsis_line12} ]

DESCRIPTION
   
     clk lets you clock in and out of work, tracking how many minutes you've spent working each day.
   
     Options include:
   
     ${clk_synopsis_line2}
             Print help page. Optionally add 'error' to see the error codes.
   
     ${clk_synopsis_line3}
             Clock in to work labeled with a single-word <tag>. The <tag> is of the form <top>[.<nextLevel>*] where <top> is a top-level tag and <nextLevel> are next-level tags under the <top> tag. At summary time (see 'past' option), <top> tags are summarized in a dedicated section. Optionally specify the number of <minutes> ago at which the clock in happened. Clock automatically calculates the number of minutes in the session and records it to the log. Clock always records time in the locally-set time zone. Behind the scenes, clocking in adds a temporary record of the starting time and tag for a session in the format 'started<tab>start time<tab>tag<tab>paused seconds<tab>paused epoch' where 'started' is simply a keyword and <tab> is a tab character.

     ${clk_synopsis_line4}
             Clock out from work labeled with a single-word <tag>. See 'in' option above for the <tag> format. Optionally specify either the number of <minutes> ago or the <timestamp> at which the session ended. The <timestamp> should be in the format '${clk_user_facing_fmt}'. Optionally specify what you worked on by typing 'on' followed by a description of what you worked on. Note that the 'on' suboption must be the last suboption passed in, as all subsequent words are parsed as a part of the description. Clock automatically calculates the number of minutes in the session and records it to the log. The clock-in record is overridden upon clocking out by a permanent record of the format '${CLK_HEADER}'.

     ${clk_synopsis_line5}
             As syntactic sugar, the 'switch' option clocks out of the current session and clocks in to a new session in <tag> at the same time. Optionally specify what you worked on in the previous session by typing 'on' followed by a description of what you worked on. Note that the 'on' suboption must be the last suboption passed in, as all subsequent words are parsed as a part of the description.
   
     ${clk_synopsis_line6}
             Manually add a session of <minutes> length to the log, ending at the time of command call. Optionally specify either the number of <minutes> ago or the <timestamp> at which the session ended. The <timestamp> should be in the format '${clk_user_facing_fmt}'. Optionally specify what you worked on by typing 'on' followed by a description of what you worked on. Note that the 'on' suboption must be the last suboption passed in, as all subsequent words are parsed as a part of the description.
   
     ${clk_synopsis_line7}
             Extend the last session (only if complete) record in the log to the current time or, optionally, to an earlier time as specified by minus <minutes> or at <timestamp>.

     ${clk_synopsis_line8}
             Remove the last session record, whether incomplete or complete, and see what was removed. A synonym for 'remove' is 'pop'.
   
     ${clk_synopsis_line9}
             Pause or resume the current session. Behind the scenes, 'pause' updates the 'paused epoch' field to the current epoch timestamp, while 'resume' clears the 'paused epoch' field and updates the 'paused seconds' field as appropriate.

     ${clk_synopsis_line10}
             Open the clock log file itself. It is helpful for manually editing session details. The clock log records work sessions as rows. Its implicit header is '${CLK_HEADER}'.

     ${clk_synopsis_line11}
             Prints the last entry of the clock log.
   
     ${clk_synopsis_line12}
             Prints a useful summary of clock records over the past <number> of day(s) or week(s), grouping the results by tag. 'dtn' returns a summary of the day since midnight while 'day' returns a summary of the past 24 hours. If no <number> is given, the number is assumed to be 1. Optionally specify the starting point of the look-back summary via the 'minus <number> hour(s)' suboption.
CLK_MAN_DOC
   
read -d '' CLK_ERROR_VAR << CLK_ERROR_DOC
EXIT STATUS
   
     0       No error.
     1       Argument error.
     2       Log access / modification error.
     3       Incompatible operating system.
     4       Date conversion error.
     5       Invalid log state.
     6       Summarization failed.
CLK_ERROR_DOC

# Detect current operating system
current_os="$( uname )"
case $current_os in
	Linux|Darwin) : ;;
	*) printf "Clock doesn't know how to operate in the '$current_os' operating system.\n" >&2 && exit 3 ;;
esac

#### Help Page #####
if [ "$#" -eq 0 ]; then
	clear
	printf "\n${CLK_SYN_VAR}\n\n"
	exit
fi

if [ "$1" = 'help' ]; then
	clear
	printf "${CLK_MAN_VAR}\n\n"
	if [ -n "$2" ] && [ "$2" = 'error' ]; then
		printf "${CLK_ERROR_VAR}\n\n"
	fi
	exit	
fi

#### Parse & check input without performing functions #####
clk_subfunction="" # in, out, add, undo, log, review
clk_tag="" # any one-word alphanumeric
clk_minus_minutes="" # any positive integer
clk_at_timestamp="" # in clk_fmt
clk_for_minutes="" # any positive integer
clk_add_end_timestamp="" # in clk_fmt
clk_past_days="" # any positive integer
clk_past_minus_hours=0 # any positive integer; default to 0
clk_dtn="" # day-to-now toggle; default to empty

if [ -z "$1" ]; then printf "Missing option for clk\n" >&2 && exit 1; fi

case "$1" in
in|out|switch)
	clk_subfunction="$1"

	if [ -z "$2" ]; then printf "Missing <tag> in 'clk $1 <tag>'\n" >&2 && exit 1; fi

	clk_tag="$2"

	while [ -n "$3" ]; do
		case "$3" in
		minus)
			if [ -z "$4" ]; then printf "Missing <minutes> in 'clk $1 $2 $3 <minutes>'\n" >&2 && exit 1; fi
			if [ -n "$4" ] && ! printf '%s' "$4" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <minutes> in 'clk $1 $2 $3 <minutes>'\n" >&2 && exit 1; fi
			clk_minus_minutes=$4
			shift; shift; # consume minus <minutes>
			;;

		at)
			if [ -z "$4" ]; then printf "Missing <timestamp> in 'clk $1 $2 $3 <timestamp>'\n" >&2 && exit 1; fi
			if [ -n "$4" ] && ! printf '%s' "$4" | grep -Eq '^[0-9]{4}\.[0-9]{2}\.[0-9]{2}-[0-9]{2}:[0-9]{2}$'; then printf "Please provide a valid timestamp in the format '${clk_user_facing_fmt}' for <timestamp> in 'clk $1 $2 $3 <timestamp>'\n" >&2 && exit 1; fi
			clk_at_timestamp="$4"
			shift; shift; # consume at <timestamp>
			;;

		on)
			if [ "$1" = 'in' ]; then printf "Unknown suboption '$3' after 'clk $1 $2'\n" >&2 && exit 1; fi
			if [ -z "$4" ]; then printf "Missing <description> in 'clk $1 $2 $3 <description>'\n" >&2 && exit 1; fi
			description_args="${@:4}"
			if [ -n "${description_args}" ] && printf '%s' "${description_args}" | grep -q "$CLK_TAB"; then printf "Please provide a valid description that does not include a tab for <description> in 'clk $1 $2 $3 <description>'\n" >&2 && exit 1; fi
			if [ -n "${description_args}" ] && printf '%s' "${description_args}" | grep -Eq '^minus|at$'; then printf "Please provide a valid description that does not include 'minus' or 'at' in 'clk $1 $2 $3 <description>'\n" >&2 && exit 1; fi
			clk_on_description="${description_args}"
			break; # after on, do not process any more suboptions
			;;
		
		*) 	printf "Unknown suboption '$3' after 'clk $1 $2'\n" >&2 && exit 1
			;;
		esac
	done

	;;

extend)
	clk_subfunction="$1"
	
	if [ -n "$2" ]; then
		case "$2" in
		minus)
			if [ -z "$3" ]; then printf "Missing <minutes> in 'clk $1 $2 <minutes>'\n" >&2 && exit 1; fi
			if [ -n "$3" ] && ! printf '%s' "$3" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <minutes> in 'clk $1 $2 <minutes>'\n" >&2 && exit 1; fi
			clk_minus_minutes=$3
			;;

		at)
			if [ -z "$3" ]; then printf "Missing <timestamp> in 'clk $1 $2 <timestamp>'\n" >&2 && exit 1; fi
			if [ -n "$3" ] && ! printf '%s' "$3" | grep -Eq '^[0-9]{4}\.[0-9]{2}\.[0-9]{2}-[0-9]{2}:[0-9]{2}$'; then printf "Please provide a valid timestamp in the format '${clk_user_facing_fmt}' for <timestamp> in 'clk $1 $2 <timestamp>'\n" >&2 && exit 1; fi
			clk_at_timestamp="$3"
			;;

		*) 	printf "Unknown suboption '$2' after 'clk $1'\n" >&2 && exit 1
			;;
		esac
	fi
	;;

add)
	clk_subfunction="$1"
	
	if [ -z "$2" ]; then printf "Missing <tag> in 'clk $1 <tag> for <minutes>'\n" >&2 && exit 1; fi

	clk_tag="$2"

	if [ -z "$3" ]; then printf "Missing 'for' keyword in 'clk $1 $2 for <minutes>'\n" >&2 && exit 1; fi
	if [ "$3" != 'for' ]; then printf "Expecting 'for <minutes>' as in 'clk $1 $2 for <minutes>'\n" >&2 && exit 1; fi

	case "$3" in
	for)
		if [ -z "$4" ]; then printf "Missing <minutes> in 'clk $1 $2 $3 <minutes>'\n" >&2 && exit 1; fi
		if [ -n "$4" ] && ! printf '%s' "$4" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <minutes> in 'clk $1 $2 $3 <minutes>'\n" >&2 && exit 1; fi
		clk_for_minutes="$4"

		while [ -n "$5" ]; do
			case "$5" in
			minus)
				if [ -z "$6" ]; then printf "Missing <minutes> in 'clk $1 $2 $3 $4 $5 <minutes>'\n" >&2 && exit 1; fi
				if ! printf '%s' "$6" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <minutes> in 'clk $1 $2 $3 $4 $5 <minutes>'\n" >&2 && exit 1; fi
				clk_minus_minutes=$6
				shift; shift; # consume minus <minutes>
				;;

			at)
				if [ -z "$6" ]; then printf "Missing <timestamp> in 'clk $1 $2 $3 $4 $5 <timestamp>'\n" >&2 && exit 1; fi
				if ! printf '%s' "$6" | grep -Eq '^[0-9]{4}\.[0-9]{2}\.[0-9]{2}-[0-9]{2}:[0-9]{2}$'; then printf "Please provide a valid timestamp in the format '${clk_user_facing_fmt}' for <timestamp> in 'clk $1 $2 $3 $4 $5 <timestamp>'\n" >&2 && exit 1; fi
				clk_add_end_timestamp="$6"
				shift; shift; # consume at <timestamp>
				;;

			on)
				if [ -z "$6" ]; then printf "Missing <description> in 'clk $1 $2 $3 $4 $5 <description>'\n" >&2 && exit 1; fi
				description_args="${@:6}"
				if [ -n "${description_args}" ] && printf '%s' "${description_args}" | grep -q "$CLK_TAB"; then printf "Please provide a valid description that does not include a tab for <description> in 'clk $1 $2 $3 $4 $5 <description>'\n" >&2 && exit 1; fi
				if [ -n "${description_args}" ] && printf '%s' "${description_args}" | grep -Eq '^minus|at$'; then printf "Please provide a valid description that does not include 'minus' or 'at' in 'clk $1 $2 $3 $4 $5 <description>'\n" >&2 && exit 1; fi
				clk_add_on_description="${description_args}"
				break; # after on, do not process any more suboptions
				;;

			*) 	printf "Unknown suboption '$5' after 'clk $1 $2 $3 $4'\n" >&2 && exit 1
				;;
			esac
		done

		;;

	*) 	printf "Unknown suboption '$3' after 'clk $1 $2'\n" >&2 && exit 1
		;;
	esac

	;;

remove|pop|pause|p|resume|r|log|last|l)
	if [ "$#" -gt 1 ]; then
		printf "Too many arguments. Usage: 'clk $1'\n"
		exit 1
	fi
	
	clk_subfunction="$1"

	case "${clk_subfunction}" in
	p) clk_subfunction='pause' ;;
	r) clk_subfunction='resume' ;;
	esac
	;;

past)
	clk_subfunction="$1"

	if [ -z "$2" ]; then printf "Missing second word in '${clk_synopsis_line12}'\n" >&2 && exit 1; fi

	case "$2" in
	dtn|day|week)
		case "$2" in
		dtn) clk_dtn=true ;;
		day) clk_past_days=1 ;;
		week) clk_past_days=7 ;;
		esac

		if [ -n "$3" ]; then
			case "$3" in
			minus)
				if [ -z "$4" ]; then printf "Missing <number> in 'clk $1 $2 $3 <number> hour(s)'\n" >&2 && exit 1; fi
				if ! printf '%s' "$4" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <number> in 'clk $1 $2 $3 <number> hour(s)'\n" >&2 && exit 1; fi

				if [ -z "$5" ]; then printf "Missing hour(s) keyword after 'clk $1 $2 $3 $4'\n" >&2 && exit 1; fi
				case "$5" in
				hour|hours)
					clk_past_minus_hours="$4"
					;;
				*) printf "Unknown suboption '$5' after 'clk $1 $2 $3 $4'\n" >&2 && exit 1
					;;
				esac
				;;

			*) 	printf "Unknown suboption '$3' after 'clk $1 $2'\n" >&2 && exit 1
				;;
			esac
		fi
		;;
	*)
		if printf '%s' "$2" | grep -Eq '^[0-9]+$'; then

			if [ -z "$3" ]; then printf "Missing 'days' or 'weeks' keyword after 'clk $1 $2'\n" >&2 && exit 1; fi

			case "$3" in
			days) 
				clk_past_days="$2"
				;;
			weeks)
				clk_past_days="$(( $2 * 7 ))"
				;;
			*) printf "Unknown suboption '$3' after 'clk $1 $2'\n" >&2 && exit 1
				;;
			esac

			if [ -n "$4" ]; then
				case "$4" in
				minus)
					if [ -z "$5" ]; then printf "Missing <number> in 'clk $1 $2 $3 $4 <number> hour(s)'\n" >&2 && exit 1; fi
					if ! printf '%s' "$5" | grep -Eq '^[0-9]+$'; then printf "Please provide a positive integer for <number> in 'clk $1 $2 $3 $4 <number> hour(s)'\n" >&2 && exit 1; fi

					if [ -z "$6" ]; then printf "Missing hour(s) keyword after 'clk $1 $2 $3 $4 $5'\n" >&2 && exit 1; fi
					case "$6" in
					hour|hours)
						clk_past_minus_hours="$5"
						;;
					*) printf "Unknown suboption '$6' after 'clk $1 $2 $3 $4 $5'\n" >&2 && exit 1
						;;
					esac
					;;

				*) 	printf "Unknown suboption '$4' after 'clk $1 $2 $3'\n" >&2 && exit 1
					;;
				esac
			fi

		else
			printf "Unknown suboption '$2' after 'clk $1'\n" >&2 && exit 1
		fi
		;;
	esac
	;;

*)	printf "Unknown option '$1' after 'clk'\n" >&2 && exit 1
;;
esac

#### Make sure clock log exists ####
clk_dir="${XDG_DATA_HOME:-$HOME/.local/share}/clk"
if ! [ -d "$clk_dir" ]; then
	printf "\nCreating clock log directory at %s\n" "$clk_dir"
	mkdir -p "$clk_dir"
fi
clk_log=${clk_dir}/clk.tsv
if ! [ -f $clk_log ]; then 
	printf "Creating clock log file at %s\n" "$clk_log"
	touch $clk_log
fi
## Ensure that the clock log always ends with the last non-empty line ##
clk_log_tmp=${clk_log}.tmp
# -s checks for file size > 0
while
	[ -s "$clk_log" ] && 
	last_line=$(tail -1 "$clk_log") &&
	[ -z "$last_line" ] || 
	printf '%s' "$last_line" | grep -Eq '^ *$' ||
	printf '%s' "$last_line" | grep -Eq '^	$'
do
	if [ $( wc -l "$clk_log" | cut -d' ' -f1 ) -eq 1 ]; then
		printf "\nClearing clock log of unaccounted-for control characters\n"
		> "$clk_log"
	else
		printf "\nRemoving trailing blank line in clock log\n"
		sed -e '$d' "$clk_log" > $clk_log_tmp || exit 2
		mv $clk_log_tmp $clk_log || exit 2
	fi
done
# At this point the last_line variable should hold the last line content.

#### Perform log validity check for in, extend, add, past ####
if [ "$clk_subfunction" = 'in' ] || [ "$clk_subfunction" = 'extend' ] || [ "$clk_subfunction" = 'add' ] || [ "$clk_subfunction" = 'past' ] ; then
	# If file is empty skip this guard. 
	# If file is non-empty and last line is still in 'started' format, then interactively prompt user to give a session length for the started session or remove the partial record.
	if [ -n "$last_line" ] && [ "$(printf "$last_line" | cut -d"$CLK_TAB" -f1)" = 'started' ]; then
		start_timestamp="$(printf "$last_line" | cut -d"$CLK_TAB" -f2)"
		start_tag="$(printf "$last_line" | cut -d"$CLK_TAB" -f3)"

		# first exit early if 'extend' option, since we want to prevent unintended behavior
		if [ "$clk_subfunction" = 'extend' ]; then
			printf "Cannot extend when there is still an ongoing session in\n  %s\n  that started at\n  %s\n" "${start_tag}" "${start_timestamp}"
			exit 1
		fi

		repeat_prompt='true'
		while [ "$repeat_prompt" = 'true' ]; do
			
			printf "\nPlease provide a length in minutes for the session in\n  ${start_tag}\n  that began at\n  ${start_timestamp}\nor type 'r' to remove the record.\n\n"
			read -p "Session length: " user_input_session_mins

			if [ "$user_input_session_mins" = 'r' ]; then
				sed -e '$d' $clk_log > $clk_log_tmp || exit 2
				mv $clk_log_tmp $clk_log || exit 2
				printf "\nRemoved partial record\n"
				printf "  ${last_line}\n"
				repeat_prompt='false'

			elif printf '%s' "$user_input_session_mins" | grep -Eq '^[0-9]+$'; then
				# Calculate end timestamp based on start timestamp and user-provided session length
				end_timestamp=""
				case "$current_os" in
					Linux)
						# timestamp format in clk_fmt
						start_epochtime="$( date -d "$start_timestamp" +'%s' )" || exit 4
						end_epochtime="$(( $start_epochtime + $user_input_session_mins * 60 ))"
						end_timestamp="$( date -d @"$end_epochtime" +$clk_fmt )" || exit 4
						;;
					Darwin)
						end_timestamp="$( date -j -v+${user_input_session_mins}M -f $clk_fmt "$start_timestamp" +$clk_fmt )" || exit 4
						;;
				esac

				new_record="${end_timestamp}${CLK_TAB}${start_tag}${CLK_TAB}${user_input_session_mins}"
				sed -e '$d' $clk_log > $clk_log_tmp || exit 2
				printf "${new_record}\n" >> $clk_log_tmp || exit 2
				mv $clk_log_tmp $clk_log || exit 2

				printf "\nReplaced partial session with a full session in\n  ${start_tag}\n  that was active for\n  ${user_input_session_mins} minutes\n  and ended at\n  ${end_timestamp}.\n"

				printf "\nIn addition:\n"

				repeat_prompt='false'

			else
				printf "\nInvalid user input '$user_input_session_mins'. Please try again.\n"
			fi

		done

	fi

fi

#### Perform 'in' option ####
# Note that pre-in log validity check has already been performed
if [ "$clk_subfunction" = 'in' ]; then
	## Add 'in' portion of session to log ##
	# if needed, calculate adjusted timestamp for start time
	start_timestamp=""
	if [ -n "$clk_at_timestamp" ]; then
		start_timestamp="$clk_at_timestamp"
	else
		if [ -n "$clk_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clk_minus_minutes * 60 ))
					start_timestamp="$( date -d @$adjusted_epochtime +$clk_fmt )"
					;;
				Darwin)
					start_timestamp="$(date -v -${clk_minus_minutes}M +$clk_fmt)"
					;;
			esac
		else
			start_timestamp="$(date +$clk_fmt)"
		fi
	fi

	total_paused_seconds=0
	last_paused_at=""

	printf "started\t${start_timestamp}\t${clk_tag}\t${total_paused_seconds}\t${last_paused_at}\n" >> $clk_log &&
		printf "\nAdded new session in\n  ${clk_tag}\n  that started at\n  ${start_timestamp}\n" ||
		exit 2

	printf '\n'
	exit 0
fi

#### Perform 'extend' option ####
# With minor tweaks, this is a copy-and-paste from clock-out subfunction.
if [ "$clk_subfunction" = 'extend' ]; then
	# Guard-check that the file is non-empty
	if [ -z "$last_line" ]; then
		printf "Clock log is empty. Cannot extend last session.\n" >&2 && exit 5
	fi

	# Calculate adjusted timestamp for extended_end_timestamp
	extended_end_timestamp=""
	if [ -n "$clk_at_timestamp" ]; then
		extended_end_timestamp="$clk_at_timestamp"
	else
		if [ -n "$clk_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clk_minus_minutes * 60 ))
					extended_end_timestamp="$( date -d @$adjusted_epochtime +$clk_fmt )"
					;;
				Darwin)
					extended_end_timestamp="$(date -v -${clk_minus_minutes}M +$clk_fmt)"
					;;
			esac
		else
			extended_end_timestamp="$(date +$clk_fmt)"
		fi
	fi

	# Obtain previous end-timestamp
	prev_end_timestamp="$(printf "$last_line" | cut -d"$CLK_TAB" -f1)"

	# Calculate session extension length based on (adjusted) end timestamp and last sesh end timestamp
	prev_end_epochtime=""
	extended_end_epochtime=""
	case "$current_os" in
		Linux)
			# timestamp format in clk_fmt
			prev_end_epochtime="$( date -d "$prev_end_timestamp" +'%s' )" || exit 4
			extended_end_epochtime="$( date -d "$extended_end_timestamp" +'%s' )" || exit 4
			;;
		Darwin)
			prev_end_epochtime="$( date -j -f $clk_fmt "$prev_end_timestamp" +'%s' )" || exit 4
			extended_end_epochtime="$( date -j -f $clk_fmt "$extended_end_timestamp" +'%s' )" || exit 4
			;;
	esac

	difference_in_seconds=$(( $extended_end_epochtime - $prev_end_epochtime ))

	# if the difference is negative, inform the user end time is invalid.
	if printf '%s' "$difference_in_seconds" | grep -Eq '^-'; then
		printf "Clock-extend time\n  ${extended_end_timestamp}\n  cannot be earlier than previous clock-out time\n  ${prev_end_timestamp}\n" && exit 1
	fi

	# Obtain previous length & calculate extended length
	prev_length="$(printf "$last_line" | cut -d"$CLK_TAB" -f3)"
	extension_length=$(( $difference_in_seconds / 60 ))
	updated_length=$(( $prev_length + $extension_length ))

	# obtain previous session tag
	prev_sesh_tag="$(printf "$last_line" | cut -d"$CLK_TAB" -f2)"

	# obtain previous session description
	prev_sesh_desc="$(printf "$last_line" | cut -d"$CLK_TAB" -f4)"

	# Replace last completed-session record with new completed-session record
	new_record="${extended_end_timestamp}${CLK_TAB}${prev_sesh_tag}${CLK_TAB}${updated_length}${CLK_TAB}${prev_sesh_desc}"
	sed -e '$d' $clk_log > $clk_log_tmp || exit 2
	printf "${new_record}\n" >> $clk_log_tmp || exit 2
	mv $clk_log_tmp $clk_log || exit 2

	# set description string
	description_string=""
	if [ -n "${prev_sesh_desc}" ]; then
		description_string="  on ${prev_sesh_desc}"
		description_string+=$'\n'
	fi

	printf "\nExtended last session in\n  %s\n%s  by\n  %s minutes\n  for a total session length of\n  %d minutes\n  ending at\n  %s.\n" "${prev_sesh_tag}" "${description_string}" "${extension_length}" "${updated_length}" "${extended_end_timestamp}"

	printf '\n'
	exit 0
fi

#### Perform log validity check for out, switch, pause, resume ####
if [ "$clk_subfunction" = 'out' ] || [ "$clk_subfunction" = 'switch' ] || [ "$clk_subfunction" = 'pause' ] || [ "$clk_subfunction" = 'resume' ] ; then
	# If file is empty, or 
	# if file is non-empty and last line is NOT in 'started' format, then quit and ask user to clock in first.
	if [ -z "$last_line" ] || ! [ "$(printf "$last_line" | cut -d"$CLK_TAB" -f1)" = 'started' ]; then
		printf "No latest clock-in record found. Please clock in first.\n" >&2 && exit 5
	fi
fi

#### Perform 'out' option ####
if [ "$clk_subfunction" = 'out' ]; then
	## Guard - Check if latest partial record has the same tag ##
	start_tag="$(printf "$last_line" | cut -d"$CLK_TAB" -f3)"
	if ! [ "$clk_tag" = "$start_tag" ]; then
		printf "The clock-out work tag '$clk_tag' does not match the clock-in work tag '$start_tag'\n" >&2 && exit 1
	fi

	## Add 'out' portion of session to log ##
	# if needed, calculate adjusted timestamp for end time
	end_timestamp=""
	if [ -n "$clk_at_timestamp" ]; then
		end_timestamp="$clk_at_timestamp"
	else
		if [ -n "$clk_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clk_minus_minutes * 60 ))
					end_timestamp="$( date -d @$adjusted_epochtime +$clk_fmt )"
					;;
				Darwin)
					end_timestamp="$(date -v -${clk_minus_minutes}M +$clk_fmt)"
					;;
			esac
		else
			end_timestamp="$(date +$clk_fmt)"
		fi
	fi

	# calculate session length based on (adjusted) end timestamp and start timestamp
	start_timestamp="$(printf "$last_line" | cut -d"$CLK_TAB" -f2)"
	start_epochtime=""
	end_epochtime=""
	case "$current_os" in
		Linux)
			# timestamp format in clk_fmt
			start_epochtime="$( date -d "$start_timestamp" +'%s' )" || exit 4
			end_epochtime="$( date -d "$end_timestamp" +'%s' )" || exit 4
			;;
		Darwin)
			start_epochtime="$( date -j -f $clk_fmt "$start_timestamp" +'%s' )" || exit 4
			end_epochtime="$( date -j -f $clk_fmt "$end_timestamp" +'%s' )" || exit 4
			;;
	esac

	difference_in_seconds=$(( $end_epochtime - $start_epochtime ))

	# if the difference is negative, inform the user end time is invalid.
	if printf '%s' "$difference_in_seconds" | grep -Eq '^-'; then
		printf "Clock-out time\n  ${end_timestamp}\n  cannot be earlier than clock-in time\n  ${start_timestamp}\n" && exit 1
	fi

	# now obtain and subtract paused seconds
	paused_seconds="$( printf "$last_line" | cut -d"$CLK_TAB" -f4 )"
	# if session is currently paused, add time from last pause to now
	last_paused_at="$( printf "$last_line" | cut -d"$CLK_TAB" -f5 )"
	if [ -n "$last_paused_at" ]; then
		now_epoch="$(date +%s)"
		paused_seconds=$(( $paused_seconds + $now_epoch - $last_paused_at ))
	fi
	session_length=$(( ($difference_in_seconds - $paused_seconds) / 60 ))

	# if the session length is negative due to too much paused time, inform the user
	if printf '%s' "$session_length" | grep -Eq '^-'; then
		no_pause_session_length=$(( $difference_in_seconds / 60 ))
		paused_minutes_display=$(( $paused_seconds / 60 ))
		printf 'Current session paused time of %d minutes\n  cannot exceed total session length of %d minutes.\n' ${paused_minutes_display} ${no_pause_session_length} && exit 1
	fi

	# Replace start-session record with completed-session record
	new_record="${end_timestamp}${CLK_TAB}${clk_tag}${CLK_TAB}${session_length}${CLK_TAB}${clk_on_description}"
	sed -e '$d' $clk_log > $clk_log_tmp || exit 2
	printf "${new_record}\n" >> $clk_log_tmp || exit 2
	mv $clk_log_tmp $clk_log || exit 2

	paused_string=""
	if [ "$paused_seconds" -gt 0 ]; then
		paused_minutes_display=$(( $paused_seconds / 60 ))
		paused_string="was paused for"
		paused_string+=$'\n'
		paused_string+="  ${paused_minutes_display} minutes"
		paused_string+=$'\n  and '
	fi

	# set description string
	description_string=""
	if [ -n "$clk_on_description" ]; then
		description_string="  on ${clk_on_description}"
		description_string+=$'\n'
	fi

	printf "\nRecorded full session in\n  %s\n  starting at\n  %s\n%s  that %swas active for\n  %d minutes\n  and ended at\n  %s.\n" "${clk_tag}" "${start_timestamp}" "${description_string}" "${paused_string}" "${session_length}" "${end_timestamp}"

	printf '\n'
	exit 0
fi

### Perform 'switch' option ####
# The first half of this procedure copies from clock out (excluding the same-tag guard); the second half copies from clock in.
if [ "$clk_subfunction" = 'switch' ]; then

	# if needed, calculate adjusted timestamp for switch time
	switch_timestamp=""
	if [ -n "$clk_at_timestamp" ]; then
		switch_timestamp="$clk_at_timestamp"
	else
		if [ -n "$clk_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clk_minus_minutes * 60 ))
					switch_timestamp="$( date -d @$adjusted_epochtime +$clk_fmt )"
					;;
				Darwin)
					switch_timestamp="$(date -v -${clk_minus_minutes}M +$clk_fmt)"
					;;
			esac
		else
			switch_timestamp="$(date +$clk_fmt)"
		fi
	fi

	## Add previous session to log ##
	# calculate previous session length based on (adjusted) end timestamp and prev sesh start timestamp
	prev_sesh_start_timestamp="$(printf "$last_line" | cut -d"$CLK_TAB" -f2)"
	start_epochtime=""
	end_epochtime=""
	case "$current_os" in
		Linux)
			# timestamp format in clk_fmt
			start_epochtime="$( date -d "$prev_sesh_start_timestamp" +'%s' )" || exit 4
			end_epochtime="$( date -d "$switch_timestamp" +'%s' )" || exit 4
			;;
		Darwin)
			start_epochtime="$( date -j -f $clk_fmt "$prev_sesh_start_timestamp" +'%s' )" || exit 4
			end_epochtime="$( date -j -f $clk_fmt "$switch_timestamp" +'%s' )" || exit 4
			;;
	esac

	difference_in_seconds=$(( $end_epochtime - $start_epochtime ))

	# if the difference is negative, inform the user end time is invalid.
	if printf '%s' "$difference_in_seconds" | grep -Eq '^-'; then
		printf "Clock-switch time\n  ${switch_timestamp}\n  cannot be earlier than previous session's clock-in time\n  ${prev_sesh_start_timestamp}\n" && exit 1
	fi

	# obtain and subtract paused seconds from previous session
	prev_sesh_paused_seconds="$(printf "$last_line" | cut -d"$CLK_TAB" -f4)"
	prev_sesh_last_paused_at="$(printf "$last_line" | cut -d"$CLK_TAB" -f5)"
	if [ -n "$prev_sesh_last_paused_at" ]; then
		prev_sesh_paused_seconds=$(( $prev_sesh_paused_seconds + $end_epochtime - $prev_sesh_last_paused_at ))
	fi
	session_length=$(( ($difference_in_seconds - $prev_sesh_paused_seconds) / 60 ))

	# obtain previous session tag
	prev_sesh_tag="$(printf "$last_line" | cut -d"$CLK_TAB" -f3)"

	# replace start-session record with completed-session record
	if [ -n "${clk_on_description}" ]; then
		new_record="${switch_timestamp}${CLK_TAB}${prev_sesh_tag}${CLK_TAB}${session_length}${CLK_TAB}${clk_on_description}"
	else
		new_record="${switch_timestamp}${CLK_TAB}${prev_sesh_tag}${CLK_TAB}${session_length}${CLK_TAB}"
	fi
	sed -e '$d' $clk_log > $clk_log_tmp || exit 2
	printf "${new_record}\n" >> $clk_log_tmp || exit 2
	mv $clk_log_tmp $clk_log || exit 2

	# set description string
	description_string=""
	if [ -n "$clk_on_description" ]; then
		description_string="  on ${clk_on_description}"
		description_string+=$'\n'
	fi

	paused_string=""
	if [ "$prev_sesh_paused_seconds" -gt 0 ]; then
		paused_minutes_display=$(( $prev_sesh_paused_seconds / 60 ))
		paused_string="was paused for"
		paused_string+=$'\n'
		paused_string+="  ${paused_minutes_display} minutes"
		paused_string+=$'\n  and '
	fi

	printf "\nRecorded full session in\n  %s\n%s  that %swas active for\n  %d minutes\n  and ended at\n  %s.\n" "${prev_sesh_tag}" "${description_string}" "${paused_string}" "${session_length}" "${switch_timestamp}"

	## Add start of new session to log ##

	total_paused_seconds=0
	last_paused_at=""

	printf "started\t${switch_timestamp}\t${clk_tag}\t${total_paused_seconds}\t${last_paused_at}\n" >> $clk_log &&
		printf "\nAdded new session in\n  ${clk_tag}\n  that started at\n  ${switch_timestamp}\n" ||
		exit 2
	
	printf '\n'
	exit 0
fi

#### Perform 'add' option ####
# Note that pre-add log validity check has already been performed
if [ "$clk_subfunction" = 'add' ]; then
	## Add full session to log ##
	# if needed, calculate adjusted timestamp for end time
	if [ -z "$clk_add_end_timestamp" ]; then
		clk_add_end_timestamp=""
		if [ -n "$clk_minus_minutes" ]; then
			case "$current_os" in
				Linux)
					current_epochtime="$(date +'%s')"
					adjusted_epochtime=$(( $current_epochtime - $clk_minus_minutes * 60 ))
					clk_add_end_timestamp="$( date -d @$adjusted_epochtime +$clk_fmt )"
					;;
				Darwin)
					clk_add_end_timestamp="$(date -v -${clk_minus_minutes}M +$clk_fmt)"
					;;
			esac
		else
			clk_add_end_timestamp="$(date +$clk_fmt)"
		fi
	fi

	# add record
	add_record="${clk_add_end_timestamp}${CLK_TAB}${clk_tag}${CLK_TAB}${clk_for_minutes}${CLK_TAB}${clk_add_on_description}"
	printf "${add_record}\n" >> $clk_log || exit 2

	# set description string
	description_string=""
	if [ -n "$clk_add_on_description" ]; then
		description_string="  on ${clk_add_on_description}"
		description_string+=$'\n'
	fi

	printf "\nRecorded full session in\n  %s\n%s  that was active for\n  %d minutes\n  and ended at\n  %s\n" "${clk_tag}" "${description_string}" "${clk_for_minutes}" "${clk_add_end_timestamp}"

	printf '\n'
	exit 0
fi

#### Perform 'remove' or 'pop' option ####
if [ "$clk_subfunction" = 'remove' ] || [ "$clk_subfunction" = 'pop' ]; then
	clk_verb="${clk_subfunction}"
	## Guard - Check if current log is pre-remove valid ##
	if [ -z "$last_line" ]; then
		printf "No clock record found. Cannot ${clk_verb} any record.\n" >&2 && exit 5
	fi

	## Remove last log item & print it ##
	sed -e '$d' $clk_log > $clk_log_tmp || exit 2
	mv $clk_log_tmp $clk_log || exit 2
	if [ "$clk_subfunction" = 'remove' ]; then 
		clk_verb='Removed'
	elif [ "$clk_subfunction" = 'pop' ]; then
		clk_verb='Popped'
	fi
	printf "\n${clk_verb} record\n"
	printf "  ${last_line}\n"

	printf '\n'
	exit 0
fi

#### Perform 'pause' option ####
if [ "$clk_subfunction" = 'pause' ]; then
	# obtain existing fields
	start_timestamp="$(printf "$last_line" | cut -d"$CLK_TAB" -f2)"
	current_sesh_tag="$(printf "$last_line" | cut -d"$CLK_TAB" -f3)"
	current_sesh_paused_secs="$(printf "$last_line" | cut -d"$CLK_TAB" -f4)"
	current_sesh_paused_at="$(printf "$last_line" | cut -d"$CLK_TAB" -f5)"
	if [ -n "$current_sesh_paused_at" ]; then
		pause_display="$(date -r "$current_sesh_paused_at" +$clk_fmt 2>/dev/null || printf '%s' "$current_sesh_paused_at")"
		printf 'Cannot pause current session, as it was already paused at %s\n' "${pause_display}"
		exit 5
	fi
	# replace record with new one where paused time field is set to epoch timestamp
	pause_epoch="$(date +%s)"
	pause_display="$(date +$clk_fmt)"
	new_record="started${CLK_TAB}${start_timestamp}${CLK_TAB}${current_sesh_tag}${CLK_TAB}${current_sesh_paused_secs}${CLK_TAB}${pause_epoch}"
	sed -e '$d' $clk_log > $clk_log_tmp || exit 2
	printf "${new_record}\n" >> $clk_log_tmp || exit 2
	mv $clk_log_tmp $clk_log || exit 2
	# report the pause
	printf '\nThe current session in\n  %s\n  has been paused at\n  %s\n\n' "${current_sesh_tag}" "${pause_display}"
	exit 0
fi

#### Perform 'resume' option ####
if [ "$clk_subfunction" = 'resume' ]; then
	## obtain existing fields
	start_timestamp="$(printf "$last_line" | cut -d"$CLK_TAB" -f2)"
	sesh_tag="$(printf "$last_line" | cut -d"$CLK_TAB" -f3)"
	sesh_prev_paused_secs="$(printf "$last_line" | cut -d"$CLK_TAB" -f4)"
	if ! printf '%s' "${sesh_prev_paused_secs}" | grep -Eq '^[0-9]+$'; then
		printf 'Current session paused seconds field (4th field) is not an integer. Please fix in log.\n'
		exit 5
	fi
	paused_epoch="$(printf "$last_line" | cut -d"$CLK_TAB" -f5)"
	# obtain epoch now
	now_epoch="$(date +%s)"

	## calculate new paused seconds
	difference_in_seconds=$(( $now_epoch - $paused_epoch ))

	# if the difference is negative, inform the user
	if printf '%s' "$difference_in_seconds" | grep -Eq '^-'; then
		now_display="$(date +$clk_fmt)"
		paused_display="$(date -r "$paused_epoch" +$clk_fmt 2>/dev/null || printf '%s' "$paused_epoch")"
		printf "Resume time\n  ${now_display}\n  cannot be earlier than paused time\n  ${paused_display}\n" && exit 1
	fi
	# increment paused seconds
	sesh_new_paused_secs=$(( $sesh_prev_paused_secs + $difference_in_seconds ))

	## update record
	# update paused seconds and clear paused time field
	new_record="started${CLK_TAB}${start_timestamp}${CLK_TAB}${sesh_tag}${CLK_TAB}${sesh_new_paused_secs}${CLK_TAB}"
	sed -e '$d' $clk_log > $clk_log_tmp || exit 2
	printf "${new_record}\n" >> $clk_log_tmp || exit 2
	mv $clk_log_tmp $clk_log || exit 2
	# report resume
	paused_display_mins=$(( $sesh_new_paused_secs / 60 ))
	printf '\nThe current session in\n  %s\n  has been resumed.\n  Total paused: %d seconds (%d minutes)\n\n' "${sesh_tag}" "${sesh_new_paused_secs}" "${paused_display_mins}"
	exit 0
fi

#### Perform 'log' option ####
if [ "$clk_subfunction" = 'log' ]; then
	vi $clk_log
	exit 0
fi

#### Perform 'last' option ####
if [ "$clk_subfunction" = 'last' ] || [ "$clk_subfunction" = 'l' ]; then
	printf "${last_line}\n"
	exit 0
fi

#### Perform 'past' option ####
if [ "$clk_subfunction" = 'past' ]; then
	## Guard - Check if current log is pre-past valid ##
	if [ -z "$last_line" ]; then
		printf "No clock record found. Cannot perform summary.\n" >&2 && exit 5
	fi

	## Calculate cut-off epoch ##
	if ! [ "$clk_dtn" = 'true' ]; then
		clk_past_hours_with_minus=$(( $clk_past_days * 24 + $clk_past_minus_hours ))
	fi

	# printf >&2 "clk_past_hours_with_minus: $clk_past_hours_with_minus\n"
	# printf >&2 "clk_past_minus_hours: $clk_past_minus_hours\n"
	# exit
	case "$current_os" in
		Linux)
			current_epochtime="$(date +'%s')"
			if [ "$clk_dtn" = 'true' ]; then
				startcut_epochtime="$( date -d "$( date +'%Y.%m.%d-%H:%M:%S' )" +'%s' )"
				endcut_epochtime="$current_epochtime"
			else
				startcut_epochtime=$(( $current_epochtime - $clk_past_hours_with_minus * 3600 ))
				endcut_epochtime=$(( $current_epochtime - $clk_past_minus_hours * 3600 ))
			fi
			;;
		Darwin)
			if [ "$clk_dtn" = 'true' ]; then
				startcut_epochtime="$( date -j -f '%m-%d:%H:%M:%S' "$(date +%m-%d):00:00:00" +%s )"
				endcut_epochtime="$(date +%s)"
			else
				startcut_epochtime="$(date -v -${clk_past_hours_with_minus}H +'%s')"
				endcut_epochtime="$(date -v -${clk_past_minus_hours}H +'%s')"
			fi
			;;
	esac

	## Output a helpful summary of records after cut-off time ##
	# for a more efficient algorithm:
	#   first sort the records
	#   then search backwards using tail or tac and find the earliest in-startcut and the earliest in-endcut lines' timestamps
	#   then use those timestamps to make a non-filtering awk for the final aggregation operation.

	# sort the records
	sort $clk_log > $clk_log_tmp || exit 2
	mv $clk_log_tmp $clk_log || exit 2

	# search backwards using tail and find earliest in-startcut timestamp
	first_timestamp_of_all_time="$( head -1 $clk_log | cut -d"$CLK_TAB" -f1 )"
	last_timestamp_of_all_time="$( tail -1 $clk_log | cut -d"$CLK_TAB" -f1 )"

	earliest_post_startcut_line=""
	latest_pre_endcut_line=""

	# first check if endcut is before the first timestamp. if so, there's nothing to summarize.
	case "$current_os" in
		# zeroed_fmt is clk_fmt with a standardized 00 for seconds so that the converted epoch time is consistent across calls.
		# note that we can access record_epoch outside of the if condition because variables are globally scoped by default.
		Linux)
			# if the startcut is before the first timestamp, then just use the first timestamp
			first_epochtime="$( date -d "$first_timestamp_of_all_time" +'%s' )"
			last_epochtime="$( date -d "$last_timestamp_of_all_time" +'%s' )"
			if [ "$first_epochtime" -ge "$endcut_epochtime" ]; then
				printf 'Nothing to summarize: cutoff end-time precedes earliest timestamp in clock log\n'; exit 0
			elif [ "$last_epochtime" -lt "$startcut_epochtime" ]; then
				printf 'Nothing to summarize: cutoff start-time is later than latest timestamp in clock log\n'; exit 0
			elif [ "$first_epochtime" -ge "$startcut_epochtime" ]; then
				earliest_post_startcut_line="$first_timestamp_of_all_time"
			else
				earliest_post_startcut_line="$( \
					tac $clk_log | \
					awk -F'\t' -v startcut="$startcut_epochtime" -v zeroed_fmt="${clk_fmt}:%S" \
						'{ \
							date_cmd = "date -d "$1":00 +%s"; \
							if ( ( date_cmd | getline record_epoch ) < 0 ) \
								{ print "Date conversion inside startcut search failed for timestamp " $1 > "/dev/stderr" ; exit 1; } \
							close(date_cmd); \
							if ( record_epoch > startcut ) \
								{ prev_timestamp = $1; prev_NR = NR; } \
							else \
								{ printf "%d,%s", prev_NR, prev_timestamp; exit; } \
						}' \
				)" || exit 1
			fi
			latest_pre_endcut_line="$( \
				tac $clk_log | \
				awk -F'\t' -v endcut="$endcut_epochtime" -v zeroed_fmt="${clk_fmt}:%S" \
					'{ \
						date_cmd = "date -d "$1":00 +%s"; \
						if ( ( date_cmd | getline record_epoch ) < 0 ) \
							{ print "Date conversion inside endcut search failed for timestamp " $1 > "/dev/stderr" ; exit 1; } \
						close(date_cmd); \
						if ( record_epoch < endcut ) { printf "%d,%s", NR, $1; exit; } \
					}' \
			)" || exit 1

			;;

		Darwin)
			first_epochtime="$( date -j -f "$clk_fmt" "$first_timestamp_of_all_time" +'%s' )"
			last_epochtime="$( date -j -f "$clk_fmt" "$last_timestamp_of_all_time" +'%s' )"
			if [ "$first_epochtime" -ge "$endcut_epochtime" ]; then
				printf 'Nothing to summarize: cutoff end-time precedes earliest timestamp in clock log\n'; exit 0
			elif [ "$last_epochtime" -lt "$startcut_epochtime" ]; then
				printf 'Nothing to summarize: cutoff start-time is later than latest timestamp in clock log\n'; exit 0
			elif [ "$first_epochtime" -ge "$startcut_epochtime" ]; then
				earliest_post_startcut_line="$first_timestamp_of_all_time"
			else
				# printf >&2 "startcut_epochtime: $startcut_epochtime\n"
				# printf >&2 "%s\n" "clk_fmt: $clk_fmt"
				# it is CRUCIAL to close the command after each run, otherwise the pipe will fail after too many open files.
				earliest_post_startcut_line="$( \
					tail -r $clk_log | \
					awk -F'\t' -v startcut="$startcut_epochtime" -v zeroed_fmt="${clk_fmt}:%S" \
						'{ \
							date_cmd = "date -j -f "zeroed_fmt" "$1":00 +%s"; \
							if ( ( date_cmd | getline record_epoch ) < 0 ) \
								{ print "Date conversion inside endcut search failed for timestamp " $1 > "/dev/stderr"; exit 1; } \
							close(date_cmd); \
							if ( record_epoch > startcut ) \
								{ prev_timestamp = $1; prev_NR = NR; } \
							else \
								{ printf "%d,%s", prev_NR, prev_timestamp; exit; } \
						}' \
				)" || exit 1
			fi
			latest_pre_endcut_line="$( \
				tail -r $clk_log | \
				awk -F'\t' -v endcut="$endcut_epochtime" -v zeroed_fmt="${clk_fmt}:%S" \
					'{ \
						date_cmd = "date -j -f "zeroed_fmt" "$1":00 +%s"; \
						if ( ( date_cmd | getline record_epoch ) < 0 ) \
							{ print "Date conversion inside endcut search failed for timestamp " $1 > "/dev/stderr" ; exit 1; } \
						close(date_cmd); \
						if ( record_epoch < endcut ) { printf "%d,%s", NR, $1; exit; } \
					}' \
			)" || exit 1
			;;
	esac

	# check variables
	# printf >&2 "endcut_epochtime: $endcut_epochtime\n"
	# printf >&2 "earliest_post_startcut_line: $earliest_post_startcut_line\n"
	# printf >&2 "latest_pre_endcut_line: $latest_pre_endcut_line\n"

	# obtain the line-number fields for each line.
	earliest_post_startcut_linenum="${earliest_post_startcut_line%,*}"
	latest_pre_endcut_linenum="${latest_pre_endcut_line%,*}"

	# guard-check that earliest line is not _after_ latest line, which would mean the time range is negative and summary should be empty. since the awk results are based on reverse-files, we early-exit if earliest linenum is less than latest linenum, indicating that earliest linenum actually comes _after_ latest linenum in right order.
	if [ $earliest_post_startcut_linenum -le $latest_pre_endcut_linenum ]; then
		printf 'No clock records found within the desired time range.\n' >&2 && exit 0
	fi

	# obtain timestamps
	earliest_post_startcut_timestamp="${earliest_post_startcut_line#*,}"
	latest_pre_endcut_timestamp="${latest_pre_endcut_line#*,}"


	if [ -z "$earliest_post_startcut_timestamp" ]; then
		printf "No clock records found after the desired time range start time.\n" >&2 && exit 0
	elif [ -z "$latest_pre_endcut_timestamp" ]; then
		printf "No clock records found before the desired time range end time.\n" >&2 && exit 0
	fi
	
	# using the startcut and endcut timestamps, give summary of the right records
	# note that because of the sort command at the end, the ordering of your output will be determined by the sort and not by awk.
	# note that split("", arr) is used to clear an arr
	printf "\n-- Top-level tags --\n"
	awk -F'\t' -v earliest_match="$earliest_post_startcut_timestamp" \
			-v latest_match="$latest_pre_endcut_timestamp" \
		'$0 ~ earliest_match, $0 ~ latest_match \
			{ 	\
				split("", tag_components); \
				split($2, tag_components, "."); \
				TOP[tag_components[1]]+=$3; \
				total+=$3; \
			} \
		END { \
			printf "%-17s%-7d%7.2fh\n", "TOTAL", total, (total/60); \
			for (tl in TOP) printf "%-17s%-7d%7.2fh   %06.3f%%\n", tl, TOP[tl], (TOP[tl]/60), TOP[tl]/total*100; \
		}' $clk_log | \
	sort -k2 -n -r || exit 6

	printf "\n-- Original tags --\n"
	awk -F'\t' -v earliest_match="$earliest_post_startcut_timestamp" \
			-v latest_match="$latest_pre_endcut_timestamp" \
	'$0 ~ earliest_match, $0 ~ latest_match \
		{ 	\
			TAG[$2]+=$3; \
			total+=$3; \
		} \
	END { \
		printf "%-17s%-7d%7.2fh\n", "TOTAL", total, (total/60); \
		for (t in TAG) printf "%-17s%-7d%7.2fh   %06.3f%%\n", t, TAG[t], (TAG[t]/60), TAG[t]/total*100; \
	}' $clk_log | \
	sort -k2 -n -r || exit 6

	printf '\n'
	exit 0
fi


